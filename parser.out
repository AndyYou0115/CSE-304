Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    MULTI_COMMENT
    SING_COMMENT

Grammar

Rule 0     S' -> program
Rule 1     program -> stress
Rule 2     stress -> class_decl stress
Rule 3     stress -> empty
Rule 4     class_decl -> CLASS ID EXTENDS ID { class_body_decl }
Rule 5     class_decl -> CLASS ID { class_body_decl }
Rule 6     class_body_decl -> field_decl
Rule 7     class_body_decl -> method_decl
Rule 8     class_body_decl -> constructor_decl
Rule 9     class_body_decl -> class_body_decl field_decl
Rule 10    class_body_decl -> class_body_decl method_decl
Rule 11    class_body_decl -> class_body_decl constructor_decl
Rule 12    field_decl -> modifier var_decl
Rule 13    modifier -> PUBLIC STATIC
Rule 14    modifier -> PUBLIC
Rule 15    modifier -> PRIVATE STATIC
Rule 16    modifier -> PRIVATE
Rule 17    modifier -> STATIC
Rule 18    modifier -> empty
Rule 19    var_decl -> type variables ;
Rule 20    type -> INT
Rule 21    type -> FLOAT
Rule 22    type -> BOOLEAN
Rule 23    type -> ID
Rule 24    variables -> variable temp_3
Rule 25    temp_3 -> , variable temp_3
Rule 26    temp_3 -> empty
Rule 27    variable -> ID
Rule 28    method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block
Rule 29    method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block
Rule 30    constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block
Rule 31    formals -> formal_param temp_6
Rule 32    formals -> empty
Rule 33    temp_6 -> , formal_param temp_6
Rule 34    temp_6 -> empty
Rule 35    formal_param -> type variable
Rule 36    block -> { temp_7 }
Rule 37    temp_7 -> stmt temp_7
Rule 38    temp_7 -> empty
Rule 39    stmt -> open_stmt
Rule 40    stmt -> close_stmt
Rule 41    open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt
Rule 42    open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
Rule 43    open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt
Rule 44    open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
Rule 45    close_stmt -> RETURN temp_9 ;
Rule 46    close_stmt -> stmt_expr ;
Rule 47    close_stmt -> BREAK ;
Rule 48    close_stmt -> CONTINUE ;
Rule 49    close_stmt -> var_decl
Rule 50    close_stmt -> ;
Rule 51    close_stmt -> block
Rule 52    close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
Rule 53    close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt
Rule 54    close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
Rule 55    temp_8 -> stmt_expr
Rule 56    temp_8 -> empty
Rule 57    temp_9 -> expr
Rule 58    temp_9 -> empty
Rule 59    stmt_expr -> assign
Rule 60    stmt_expr -> method_invocation
Rule 61    literal -> INT_CONST
Rule 62    literal -> FLOAT_CONST
Rule 63    literal -> STRING_CONST
Rule 64    literal -> NULL
Rule 65    literal -> TRUE
Rule 66    literal -> FALSE
Rule 67    primary -> literal
Rule 68    primary -> THIS
Rule 69    primary -> SUPER
Rule 70    primary -> LEFTPAREN expr RIGHTPAREN
Rule 71    primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN
Rule 72    primary -> lhs
Rule 73    primary -> method_invocation
Rule 74    test_1 -> expr test_2
Rule 75    test_1 -> empty
Rule 76    test_2 -> , expr test_2
Rule 77    test_2 -> empty
Rule 78    lhs -> field_access
Rule 79    field_access -> primary . ID
Rule 80    field_access -> ID
Rule 81    method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN
Rule 82    expr -> primary
Rule 83    expr -> assign
Rule 84    expr -> arith_op
Rule 85    expr -> bool_op
Rule 86    expr -> unary_op
Rule 87    assign -> lhs = expr
Rule 88    assign -> lhs INCREMENT
Rule 89    assign -> INCREMENT lhs
Rule 90    assign -> lhs DECREMENT
Rule 91    assign -> DECREMENT lhs
Rule 92    arith_op -> expr PLUS expr
Rule 93    arith_op -> expr MINUS expr
Rule 94    arith_op -> expr MULTIPLY expr
Rule 95    arith_op -> expr DIVIDE expr
Rule 96    bool_op -> expr BOOL_AND expr
Rule 97    bool_op -> expr BOOL_OR expr
Rule 98    bool_op -> expr EQUALITY expr
Rule 99    bool_op -> expr DISQUALITY expr
Rule 100   bool_op -> expr LESSTHAN expr
Rule 101   bool_op -> expr GREATERTHAN expr
Rule 102   bool_op -> expr LEQ expr
Rule 103   bool_op -> expr GEQ expr
Rule 104   unary_op -> PLUS expr
Rule 105   unary_op -> MINUS expr
Rule 106   unary_op -> NOT expr
Rule 107   empty -> <empty>

Terminals, with rules where they appear

,                    : 25 33 76
.                    : 79
;                    : 19 44 44 45 46 47 48 50 54 54
=                    : 87
BOOLEAN              : 22
BOOL_AND             : 96
BOOL_OR              : 97
BREAK                : 47
CLASS                : 4 5
CONTINUE             : 48
DECREMENT            : 90 91
DISQUALITY           : 99
DIVIDE               : 95
DO                   : 
ELSE                 : 42 52
EQUALITY             : 98
EXTENDS              : 4
FALSE                : 66
FLOAT                : 21
FLOAT_CONST          : 62
FOR                  : 44 54
GEQ                  : 103
GREATERTHAN          : 101
ID                   : 4 4 5 23 27 28 29 30 71 79 80
IF                   : 41 42 52
INCREMENT            : 88 89
INT                  : 20
INT_CONST            : 61
LEFTPAREN            : 28 29 30 41 42 43 44 52 53 54 70 71 81
LEQ                  : 102
LESSTHAN             : 100
MINUS                : 93 105
MULTIPLY             : 94
MULTI_COMMENT        : 
NEW                  : 71
NOT                  : 106
NULL                 : 64
PLUS                 : 92 104
PRIVATE              : 15 16
PUBLIC               : 13 14
RETURN               : 45
RIGHTPAREN           : 28 29 30 41 42 43 44 52 53 54 70 71 81
SING_COMMENT         : 
STATIC               : 13 15 17
STRING_CONST         : 63
SUPER                : 69
THIS                 : 68
TRUE                 : 65
VOID                 : 29
WHILE                : 43 53
error                : 
{                    : 4 5 36
}                    : 4 5 36

Nonterminals, with rules where they appear

arith_op             : 84
assign               : 59 83
block                : 28 29 30 51
bool_op              : 85
class_body_decl      : 4 5 9 10 11
class_decl           : 2
close_stmt           : 40 42 52 52 53 54
constructor_decl     : 8 11
empty                : 3 18 26 32 34 38 56 58 75 77
expr                 : 41 42 43 52 53 57 70 74 76 87 92 92 93 93 94 94 95 95 96 96 97 97 98 98 99 99 100 100 101 101 102 102 103 103 104 105 106
field_access         : 78 81
field_decl           : 6 9
formal_param         : 31 33
formals              : 28 29 30
lhs                  : 72 87 88 89 90 91
literal              : 67
method_decl          : 7 10
method_invocation    : 60 73
modifier             : 12 28 29 30
open_stmt            : 39 42 43 44
primary              : 79 82
program              : 0
stmt                 : 37 41
stmt_expr            : 46 55
stress               : 1 2
temp_3               : 24 25
temp_6               : 31 33
temp_7               : 36 37
temp_8               : 44 44 54 54
temp_9               : 44 45 54
test_1               : 71 81
test_2               : 74 76
type                 : 19 28 35
unary_op             : 86
var_decl             : 12 49
variable             : 24 25 35
variables            : 19

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stress
    (2) stress -> . class_decl stress
    (3) stress -> . empty
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }
    (107) empty -> .

    CLASS           shift and go to state 5
    $end            reduce using rule 107 (empty -> .)

    program                        shift and go to state 1
    stress                         shift and go to state 2
    class_decl                     shift and go to state 3
    empty                          shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> stress .

    $end            reduce using rule 1 (program -> stress .)


state 3

    (2) stress -> class_decl . stress
    (2) stress -> . class_decl stress
    (3) stress -> . empty
    (4) class_decl -> . CLASS ID EXTENDS ID { class_body_decl }
    (5) class_decl -> . CLASS ID { class_body_decl }
    (107) empty -> .

    CLASS           shift and go to state 5
    $end            reduce using rule 107 (empty -> .)

    class_decl                     shift and go to state 3
    stress                         shift and go to state 6
    empty                          shift and go to state 4

state 4

    (3) stress -> empty .

    $end            reduce using rule 3 (stress -> empty .)


state 5

    (4) class_decl -> CLASS . ID EXTENDS ID { class_body_decl }
    (5) class_decl -> CLASS . ID { class_body_decl }

    ID              shift and go to state 7


state 6

    (2) stress -> class_decl stress .

    $end            reduce using rule 2 (stress -> class_decl stress .)


state 7

    (4) class_decl -> CLASS ID . EXTENDS ID { class_body_decl }
    (5) class_decl -> CLASS ID . { class_body_decl }

    EXTENDS         shift and go to state 8
    {               shift and go to state 9


state 8

    (4) class_decl -> CLASS ID EXTENDS . ID { class_body_decl }

    ID              shift and go to state 10


state 9

    (5) class_decl -> CLASS ID { . class_body_decl }
    (6) class_body_decl -> . field_decl
    (7) class_body_decl -> . method_decl
    (8) class_body_decl -> . constructor_decl
    (9) class_body_decl -> . class_body_decl field_decl
    (10) class_body_decl -> . class_body_decl method_decl
    (11) class_body_decl -> . class_body_decl constructor_decl
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID LEFTPAREN formals RIGHTPAREN block
    (29) method_decl -> . modifier VOID ID LEFTPAREN formals RIGHTPAREN block
    (30) constructor_decl -> . modifier ID LEFTPAREN formals RIGHTPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . empty
    (107) empty -> .

    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 18
    STATIC          shift and go to state 17
    VOID            reduce using rule 107 (empty -> .)
    ID              reduce using rule 107 (empty -> .)
    INT             reduce using rule 107 (empty -> .)
    FLOAT           reduce using rule 107 (empty -> .)
    BOOLEAN         reduce using rule 107 (empty -> .)

    class_body_decl                shift and go to state 11
    field_decl                     shift and go to state 12
    method_decl                    shift and go to state 13
    constructor_decl               shift and go to state 14
    modifier                       shift and go to state 15
    empty                          shift and go to state 19

state 10

    (4) class_decl -> CLASS ID EXTENDS ID . { class_body_decl }

    {               shift and go to state 20


state 11

    (5) class_decl -> CLASS ID { class_body_decl . }
    (9) class_body_decl -> class_body_decl . field_decl
    (10) class_body_decl -> class_body_decl . method_decl
    (11) class_body_decl -> class_body_decl . constructor_decl
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID LEFTPAREN formals RIGHTPAREN block
    (29) method_decl -> . modifier VOID ID LEFTPAREN formals RIGHTPAREN block
    (30) constructor_decl -> . modifier ID LEFTPAREN formals RIGHTPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . empty
    (107) empty -> .

    }               shift and go to state 21
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 18
    STATIC          shift and go to state 17
    VOID            reduce using rule 107 (empty -> .)
    ID              reduce using rule 107 (empty -> .)
    INT             reduce using rule 107 (empty -> .)
    FLOAT           reduce using rule 107 (empty -> .)
    BOOLEAN         reduce using rule 107 (empty -> .)

    field_decl                     shift and go to state 22
    method_decl                    shift and go to state 23
    constructor_decl               shift and go to state 24
    modifier                       shift and go to state 15
    empty                          shift and go to state 19

state 12

    (6) class_body_decl -> field_decl .

    }               reduce using rule 6 (class_body_decl -> field_decl .)
    PUBLIC          reduce using rule 6 (class_body_decl -> field_decl .)
    PRIVATE         reduce using rule 6 (class_body_decl -> field_decl .)
    STATIC          reduce using rule 6 (class_body_decl -> field_decl .)
    VOID            reduce using rule 6 (class_body_decl -> field_decl .)
    ID              reduce using rule 6 (class_body_decl -> field_decl .)
    INT             reduce using rule 6 (class_body_decl -> field_decl .)
    FLOAT           reduce using rule 6 (class_body_decl -> field_decl .)
    BOOLEAN         reduce using rule 6 (class_body_decl -> field_decl .)


state 13

    (7) class_body_decl -> method_decl .

    }               reduce using rule 7 (class_body_decl -> method_decl .)
    PUBLIC          reduce using rule 7 (class_body_decl -> method_decl .)
    PRIVATE         reduce using rule 7 (class_body_decl -> method_decl .)
    STATIC          reduce using rule 7 (class_body_decl -> method_decl .)
    VOID            reduce using rule 7 (class_body_decl -> method_decl .)
    ID              reduce using rule 7 (class_body_decl -> method_decl .)
    INT             reduce using rule 7 (class_body_decl -> method_decl .)
    FLOAT           reduce using rule 7 (class_body_decl -> method_decl .)
    BOOLEAN         reduce using rule 7 (class_body_decl -> method_decl .)


state 14

    (8) class_body_decl -> constructor_decl .

    }               reduce using rule 8 (class_body_decl -> constructor_decl .)
    PUBLIC          reduce using rule 8 (class_body_decl -> constructor_decl .)
    PRIVATE         reduce using rule 8 (class_body_decl -> constructor_decl .)
    STATIC          reduce using rule 8 (class_body_decl -> constructor_decl .)
    VOID            reduce using rule 8 (class_body_decl -> constructor_decl .)
    ID              reduce using rule 8 (class_body_decl -> constructor_decl .)
    INT             reduce using rule 8 (class_body_decl -> constructor_decl .)
    FLOAT           reduce using rule 8 (class_body_decl -> constructor_decl .)
    BOOLEAN         reduce using rule 8 (class_body_decl -> constructor_decl .)


state 15

    (12) field_decl -> modifier . var_decl
    (28) method_decl -> modifier . type ID LEFTPAREN formals RIGHTPAREN block
    (29) method_decl -> modifier . VOID ID LEFTPAREN formals RIGHTPAREN block
    (30) constructor_decl -> modifier . ID LEFTPAREN formals RIGHTPAREN block
    (19) var_decl -> . type variables ;
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    VOID            shift and go to state 28
    ID              shift and go to state 27
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31

    var_decl                       shift and go to state 25
    type                           shift and go to state 26

state 16

    (13) modifier -> PUBLIC . STATIC
    (14) modifier -> PUBLIC .

    STATIC          shift and go to state 32
    VOID            reduce using rule 14 (modifier -> PUBLIC .)
    ID              reduce using rule 14 (modifier -> PUBLIC .)
    INT             reduce using rule 14 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 14 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PUBLIC .)


state 17

    (17) modifier -> STATIC .

    VOID            reduce using rule 17 (modifier -> STATIC .)
    ID              reduce using rule 17 (modifier -> STATIC .)
    INT             reduce using rule 17 (modifier -> STATIC .)
    FLOAT           reduce using rule 17 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 17 (modifier -> STATIC .)


state 18

    (15) modifier -> PRIVATE . STATIC
    (16) modifier -> PRIVATE .

    STATIC          shift and go to state 33
    VOID            reduce using rule 16 (modifier -> PRIVATE .)
    ID              reduce using rule 16 (modifier -> PRIVATE .)
    INT             reduce using rule 16 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 16 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 16 (modifier -> PRIVATE .)


state 19

    (18) modifier -> empty .

    VOID            reduce using rule 18 (modifier -> empty .)
    ID              reduce using rule 18 (modifier -> empty .)
    INT             reduce using rule 18 (modifier -> empty .)
    FLOAT           reduce using rule 18 (modifier -> empty .)
    BOOLEAN         reduce using rule 18 (modifier -> empty .)


state 20

    (4) class_decl -> CLASS ID EXTENDS ID { . class_body_decl }
    (6) class_body_decl -> . field_decl
    (7) class_body_decl -> . method_decl
    (8) class_body_decl -> . constructor_decl
    (9) class_body_decl -> . class_body_decl field_decl
    (10) class_body_decl -> . class_body_decl method_decl
    (11) class_body_decl -> . class_body_decl constructor_decl
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID LEFTPAREN formals RIGHTPAREN block
    (29) method_decl -> . modifier VOID ID LEFTPAREN formals RIGHTPAREN block
    (30) constructor_decl -> . modifier ID LEFTPAREN formals RIGHTPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . empty
    (107) empty -> .

    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 18
    STATIC          shift and go to state 17
    VOID            reduce using rule 107 (empty -> .)
    ID              reduce using rule 107 (empty -> .)
    INT             reduce using rule 107 (empty -> .)
    FLOAT           reduce using rule 107 (empty -> .)
    BOOLEAN         reduce using rule 107 (empty -> .)

    class_body_decl                shift and go to state 34
    field_decl                     shift and go to state 12
    method_decl                    shift and go to state 13
    constructor_decl               shift and go to state 14
    modifier                       shift and go to state 15
    empty                          shift and go to state 19

state 21

    (5) class_decl -> CLASS ID { class_body_decl } .

    CLASS           reduce using rule 5 (class_decl -> CLASS ID { class_body_decl } .)
    $end            reduce using rule 5 (class_decl -> CLASS ID { class_body_decl } .)


state 22

    (9) class_body_decl -> class_body_decl field_decl .

    }               reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    PUBLIC          reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    PRIVATE         reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    STATIC          reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    VOID            reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    ID              reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    INT             reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    FLOAT           reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)
    BOOLEAN         reduce using rule 9 (class_body_decl -> class_body_decl field_decl .)


state 23

    (10) class_body_decl -> class_body_decl method_decl .

    }               reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    PUBLIC          reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    PRIVATE         reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    STATIC          reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    VOID            reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    ID              reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    INT             reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    FLOAT           reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)
    BOOLEAN         reduce using rule 10 (class_body_decl -> class_body_decl method_decl .)


state 24

    (11) class_body_decl -> class_body_decl constructor_decl .

    }               reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    PUBLIC          reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    PRIVATE         reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    STATIC          reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    VOID            reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    ID              reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    INT             reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    FLOAT           reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)
    BOOLEAN         reduce using rule 11 (class_body_decl -> class_body_decl constructor_decl .)


state 25

    (12) field_decl -> modifier var_decl .

    }               reduce using rule 12 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 12 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 12 (field_decl -> modifier var_decl .)
    ID              reduce using rule 12 (field_decl -> modifier var_decl .)
    INT             reduce using rule 12 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 12 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 12 (field_decl -> modifier var_decl .)


state 26

    (28) method_decl -> modifier type . ID LEFTPAREN formals RIGHTPAREN block
    (19) var_decl -> type . variables ;
    (24) variables -> . variable temp_3
    (27) variable -> . ID

    ID              shift and go to state 35

    variables                      shift and go to state 36
    variable                       shift and go to state 37

state 27

    (30) constructor_decl -> modifier ID . LEFTPAREN formals RIGHTPAREN block
    (23) type -> ID .

    LEFTPAREN       shift and go to state 38
    ID              reduce using rule 23 (type -> ID .)


state 28

    (29) method_decl -> modifier VOID . ID LEFTPAREN formals RIGHTPAREN block

    ID              shift and go to state 39


state 29

    (20) type -> INT .

    ID              reduce using rule 20 (type -> INT .)


state 30

    (21) type -> FLOAT .

    ID              reduce using rule 21 (type -> FLOAT .)


state 31

    (22) type -> BOOLEAN .

    ID              reduce using rule 22 (type -> BOOLEAN .)


state 32

    (13) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 13 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 13 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC STATIC .)


state 33

    (15) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 15 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 15 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 15 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 15 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> PRIVATE STATIC .)


state 34

    (4) class_decl -> CLASS ID EXTENDS ID { class_body_decl . }
    (9) class_body_decl -> class_body_decl . field_decl
    (10) class_body_decl -> class_body_decl . method_decl
    (11) class_body_decl -> class_body_decl . constructor_decl
    (12) field_decl -> . modifier var_decl
    (28) method_decl -> . modifier type ID LEFTPAREN formals RIGHTPAREN block
    (29) method_decl -> . modifier VOID ID LEFTPAREN formals RIGHTPAREN block
    (30) constructor_decl -> . modifier ID LEFTPAREN formals RIGHTPAREN block
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PUBLIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . PRIVATE
    (17) modifier -> . STATIC
    (18) modifier -> . empty
    (107) empty -> .

    }               shift and go to state 40
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 18
    STATIC          shift and go to state 17
    VOID            reduce using rule 107 (empty -> .)
    ID              reduce using rule 107 (empty -> .)
    INT             reduce using rule 107 (empty -> .)
    FLOAT           reduce using rule 107 (empty -> .)
    BOOLEAN         reduce using rule 107 (empty -> .)

    field_decl                     shift and go to state 22
    method_decl                    shift and go to state 23
    constructor_decl               shift and go to state 24
    modifier                       shift and go to state 15
    empty                          shift and go to state 19

state 35

    (28) method_decl -> modifier type ID . LEFTPAREN formals RIGHTPAREN block
    (27) variable -> ID .

    LEFTPAREN       shift and go to state 41
    ,               reduce using rule 27 (variable -> ID .)
    ;               reduce using rule 27 (variable -> ID .)


state 36

    (19) var_decl -> type variables . ;

    ;               shift and go to state 42


state 37

    (24) variables -> variable . temp_3
    (25) temp_3 -> . , variable temp_3
    (26) temp_3 -> . empty
    (107) empty -> .

    ,               shift and go to state 44
    ;               reduce using rule 107 (empty -> .)

    temp_3                         shift and go to state 43
    empty                          shift and go to state 45

state 38

    (30) constructor_decl -> modifier ID LEFTPAREN . formals RIGHTPAREN block
    (31) formals -> . formal_param temp_6
    (32) formals -> . empty
    (35) formal_param -> . type variable
    (107) empty -> .
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 46

    formals                        shift and go to state 47
    formal_param                   shift and go to state 48
    empty                          shift and go to state 49
    type                           shift and go to state 50

state 39

    (29) method_decl -> modifier VOID ID . LEFTPAREN formals RIGHTPAREN block

    LEFTPAREN       shift and go to state 51


state 40

    (4) class_decl -> CLASS ID EXTENDS ID { class_body_decl } .

    CLASS           reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID { class_body_decl } .)
    $end            reduce using rule 4 (class_decl -> CLASS ID EXTENDS ID { class_body_decl } .)


state 41

    (28) method_decl -> modifier type ID LEFTPAREN . formals RIGHTPAREN block
    (31) formals -> . formal_param temp_6
    (32) formals -> . empty
    (35) formal_param -> . type variable
    (107) empty -> .
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 46

    type                           shift and go to state 50
    formals                        shift and go to state 52
    formal_param                   shift and go to state 48
    empty                          shift and go to state 49

state 42

    (19) var_decl -> type variables ; .

    }               reduce using rule 19 (var_decl -> type variables ; .)
    PUBLIC          reduce using rule 19 (var_decl -> type variables ; .)
    PRIVATE         reduce using rule 19 (var_decl -> type variables ; .)
    STATIC          reduce using rule 19 (var_decl -> type variables ; .)
    VOID            reduce using rule 19 (var_decl -> type variables ; .)
    ID              reduce using rule 19 (var_decl -> type variables ; .)
    INT             reduce using rule 19 (var_decl -> type variables ; .)
    FLOAT           reduce using rule 19 (var_decl -> type variables ; .)
    BOOLEAN         reduce using rule 19 (var_decl -> type variables ; .)
    IF              reduce using rule 19 (var_decl -> type variables ; .)
    WHILE           reduce using rule 19 (var_decl -> type variables ; .)
    FOR             reduce using rule 19 (var_decl -> type variables ; .)
    RETURN          reduce using rule 19 (var_decl -> type variables ; .)
    BREAK           reduce using rule 19 (var_decl -> type variables ; .)
    CONTINUE        reduce using rule 19 (var_decl -> type variables ; .)
    ;               reduce using rule 19 (var_decl -> type variables ; .)
    {               reduce using rule 19 (var_decl -> type variables ; .)
    INCREMENT       reduce using rule 19 (var_decl -> type variables ; .)
    DECREMENT       reduce using rule 19 (var_decl -> type variables ; .)
    THIS            reduce using rule 19 (var_decl -> type variables ; .)
    SUPER           reduce using rule 19 (var_decl -> type variables ; .)
    LEFTPAREN       reduce using rule 19 (var_decl -> type variables ; .)
    NEW             reduce using rule 19 (var_decl -> type variables ; .)
    INT_CONST       reduce using rule 19 (var_decl -> type variables ; .)
    FLOAT_CONST     reduce using rule 19 (var_decl -> type variables ; .)
    STRING_CONST    reduce using rule 19 (var_decl -> type variables ; .)
    NULL            reduce using rule 19 (var_decl -> type variables ; .)
    TRUE            reduce using rule 19 (var_decl -> type variables ; .)
    FALSE           reduce using rule 19 (var_decl -> type variables ; .)
    ELSE            reduce using rule 19 (var_decl -> type variables ; .)


state 43

    (24) variables -> variable temp_3 .

    ;               reduce using rule 24 (variables -> variable temp_3 .)


state 44

    (25) temp_3 -> , . variable temp_3
    (27) variable -> . ID

    ID              shift and go to state 54

    variable                       shift and go to state 53

state 45

    (26) temp_3 -> empty .

    ;               reduce using rule 26 (temp_3 -> empty .)


state 46

    (23) type -> ID .

    ID              reduce using rule 23 (type -> ID .)


state 47

    (30) constructor_decl -> modifier ID LEFTPAREN formals . RIGHTPAREN block

    RIGHTPAREN      shift and go to state 55


state 48

    (31) formals -> formal_param . temp_6
    (33) temp_6 -> . , formal_param temp_6
    (34) temp_6 -> . empty
    (107) empty -> .

    ,               shift and go to state 57
    RIGHTPAREN      reduce using rule 107 (empty -> .)

    temp_6                         shift and go to state 56
    empty                          shift and go to state 58

state 49

    (32) formals -> empty .

    RIGHTPAREN      reduce using rule 32 (formals -> empty .)


state 50

    (35) formal_param -> type . variable
    (27) variable -> . ID

    ID              shift and go to state 54

    variable                       shift and go to state 59

state 51

    (29) method_decl -> modifier VOID ID LEFTPAREN . formals RIGHTPAREN block
    (31) formals -> . formal_param temp_6
    (32) formals -> . empty
    (35) formal_param -> . type variable
    (107) empty -> .
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 46

    formals                        shift and go to state 60
    formal_param                   shift and go to state 48
    empty                          shift and go to state 49
    type                           shift and go to state 50

state 52

    (28) method_decl -> modifier type ID LEFTPAREN formals . RIGHTPAREN block

    RIGHTPAREN      shift and go to state 61


state 53

    (25) temp_3 -> , variable . temp_3
    (25) temp_3 -> . , variable temp_3
    (26) temp_3 -> . empty
    (107) empty -> .

    ,               shift and go to state 44
    ;               reduce using rule 107 (empty -> .)

    temp_3                         shift and go to state 62
    empty                          shift and go to state 45

state 54

    (27) variable -> ID .

    ,               reduce using rule 27 (variable -> ID .)
    ;               reduce using rule 27 (variable -> ID .)
    RIGHTPAREN      reduce using rule 27 (variable -> ID .)


state 55

    (30) constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN . block
    (36) block -> . { temp_7 }

    {               shift and go to state 64

    block                          shift and go to state 63

state 56

    (31) formals -> formal_param temp_6 .

    RIGHTPAREN      reduce using rule 31 (formals -> formal_param temp_6 .)


state 57

    (33) temp_6 -> , . formal_param temp_6
    (35) formal_param -> . type variable
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 46

    formal_param                   shift and go to state 65
    type                           shift and go to state 50

state 58

    (34) temp_6 -> empty .

    RIGHTPAREN      reduce using rule 34 (temp_6 -> empty .)


state 59

    (35) formal_param -> type variable .

    ,               reduce using rule 35 (formal_param -> type variable .)
    RIGHTPAREN      reduce using rule 35 (formal_param -> type variable .)


state 60

    (29) method_decl -> modifier VOID ID LEFTPAREN formals . RIGHTPAREN block

    RIGHTPAREN      shift and go to state 66


state 61

    (28) method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN . block
    (36) block -> . { temp_7 }

    {               shift and go to state 64

    block                          shift and go to state 67

state 62

    (25) temp_3 -> , variable temp_3 .

    ;               reduce using rule 25 (temp_3 -> , variable temp_3 .)


state 63

    (30) constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .

    }               reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    PUBLIC          reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    STATIC          reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    VOID            reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    ID              reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    INT             reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier ID LEFTPAREN formals RIGHTPAREN block .)


state 64

    (36) block -> { . temp_7 }
    (37) temp_7 -> . stmt temp_7
    (38) temp_7 -> . empty
    (39) stmt -> . open_stmt
    (40) stmt -> . close_stmt
    (107) empty -> .
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    }               reduce using rule 107 (empty -> .)
    IF              shift and go to state 73
    WHILE           shift and go to state 75
    FOR             shift and go to state 76
    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    temp_7                         shift and go to state 68
    stmt                           shift and go to state 69
    empty                          shift and go to state 70
    open_stmt                      shift and go to state 71
    close_stmt                     shift and go to state 72
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 65

    (33) temp_6 -> , formal_param . temp_6
    (33) temp_6 -> . , formal_param temp_6
    (34) temp_6 -> . empty
    (107) empty -> .

    ,               shift and go to state 57
    RIGHTPAREN      reduce using rule 107 (empty -> .)

    temp_6                         shift and go to state 103
    empty                          shift and go to state 58

state 66

    (29) method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN . block
    (36) block -> . { temp_7 }

    {               shift and go to state 64

    block                          shift and go to state 104

state 67

    (28) method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .

    }               reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    PUBLIC          reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    STATIC          reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    ID              reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier type ID LEFTPAREN formals RIGHTPAREN block .)


state 68

    (36) block -> { temp_7 . }

    }               shift and go to state 105


state 69

    (37) temp_7 -> stmt . temp_7
    (37) temp_7 -> . stmt temp_7
    (38) temp_7 -> . empty
    (39) stmt -> . open_stmt
    (40) stmt -> . close_stmt
    (107) empty -> .
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    }               reduce using rule 107 (empty -> .)
    IF              shift and go to state 73
    WHILE           shift and go to state 75
    FOR             shift and go to state 76
    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt                           shift and go to state 69
    temp_7                         shift and go to state 106
    empty                          shift and go to state 70
    open_stmt                      shift and go to state 71
    close_stmt                     shift and go to state 72
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 70

    (38) temp_7 -> empty .

    }               reduce using rule 38 (temp_7 -> empty .)


state 71

    (39) stmt -> open_stmt .

    IF              reduce using rule 39 (stmt -> open_stmt .)
    WHILE           reduce using rule 39 (stmt -> open_stmt .)
    FOR             reduce using rule 39 (stmt -> open_stmt .)
    RETURN          reduce using rule 39 (stmt -> open_stmt .)
    BREAK           reduce using rule 39 (stmt -> open_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> open_stmt .)
    ;               reduce using rule 39 (stmt -> open_stmt .)
    {               reduce using rule 39 (stmt -> open_stmt .)
    INCREMENT       reduce using rule 39 (stmt -> open_stmt .)
    DECREMENT       reduce using rule 39 (stmt -> open_stmt .)
    INT             reduce using rule 39 (stmt -> open_stmt .)
    FLOAT           reduce using rule 39 (stmt -> open_stmt .)
    BOOLEAN         reduce using rule 39 (stmt -> open_stmt .)
    ID              reduce using rule 39 (stmt -> open_stmt .)
    THIS            reduce using rule 39 (stmt -> open_stmt .)
    SUPER           reduce using rule 39 (stmt -> open_stmt .)
    LEFTPAREN       reduce using rule 39 (stmt -> open_stmt .)
    NEW             reduce using rule 39 (stmt -> open_stmt .)
    INT_CONST       reduce using rule 39 (stmt -> open_stmt .)
    FLOAT_CONST     reduce using rule 39 (stmt -> open_stmt .)
    STRING_CONST    reduce using rule 39 (stmt -> open_stmt .)
    NULL            reduce using rule 39 (stmt -> open_stmt .)
    TRUE            reduce using rule 39 (stmt -> open_stmt .)
    FALSE           reduce using rule 39 (stmt -> open_stmt .)
    }               reduce using rule 39 (stmt -> open_stmt .)


state 72

    (40) stmt -> close_stmt .

    IF              reduce using rule 40 (stmt -> close_stmt .)
    WHILE           reduce using rule 40 (stmt -> close_stmt .)
    FOR             reduce using rule 40 (stmt -> close_stmt .)
    RETURN          reduce using rule 40 (stmt -> close_stmt .)
    BREAK           reduce using rule 40 (stmt -> close_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> close_stmt .)
    ;               reduce using rule 40 (stmt -> close_stmt .)
    {               reduce using rule 40 (stmt -> close_stmt .)
    INCREMENT       reduce using rule 40 (stmt -> close_stmt .)
    DECREMENT       reduce using rule 40 (stmt -> close_stmt .)
    INT             reduce using rule 40 (stmt -> close_stmt .)
    FLOAT           reduce using rule 40 (stmt -> close_stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> close_stmt .)
    ID              reduce using rule 40 (stmt -> close_stmt .)
    THIS            reduce using rule 40 (stmt -> close_stmt .)
    SUPER           reduce using rule 40 (stmt -> close_stmt .)
    LEFTPAREN       reduce using rule 40 (stmt -> close_stmt .)
    NEW             reduce using rule 40 (stmt -> close_stmt .)
    INT_CONST       reduce using rule 40 (stmt -> close_stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> close_stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> close_stmt .)
    NULL            reduce using rule 40 (stmt -> close_stmt .)
    TRUE            reduce using rule 40 (stmt -> close_stmt .)
    FALSE           reduce using rule 40 (stmt -> close_stmt .)
    }               reduce using rule 40 (stmt -> close_stmt .)


state 73

    (41) open_stmt -> IF . LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> IF . LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (52) close_stmt -> IF . LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt

    LEFTPAREN       shift and go to state 107


state 74

    (70) primary -> LEFTPAREN . expr RIGHTPAREN
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 108
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 75

    (43) open_stmt -> WHILE . LEFTPAREN expr RIGHTPAREN open_stmt
    (53) close_stmt -> WHILE . LEFTPAREN expr RIGHTPAREN close_stmt

    LEFTPAREN       shift and go to state 121


state 76

    (44) open_stmt -> FOR . LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (54) close_stmt -> FOR . LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt

    LEFTPAREN       shift and go to state 122


state 77

    (50) close_stmt -> ; .

    IF              reduce using rule 50 (close_stmt -> ; .)
    WHILE           reduce using rule 50 (close_stmt -> ; .)
    FOR             reduce using rule 50 (close_stmt -> ; .)
    RETURN          reduce using rule 50 (close_stmt -> ; .)
    BREAK           reduce using rule 50 (close_stmt -> ; .)
    CONTINUE        reduce using rule 50 (close_stmt -> ; .)
    ;               reduce using rule 50 (close_stmt -> ; .)
    {               reduce using rule 50 (close_stmt -> ; .)
    INCREMENT       reduce using rule 50 (close_stmt -> ; .)
    DECREMENT       reduce using rule 50 (close_stmt -> ; .)
    INT             reduce using rule 50 (close_stmt -> ; .)
    FLOAT           reduce using rule 50 (close_stmt -> ; .)
    BOOLEAN         reduce using rule 50 (close_stmt -> ; .)
    ID              reduce using rule 50 (close_stmt -> ; .)
    THIS            reduce using rule 50 (close_stmt -> ; .)
    SUPER           reduce using rule 50 (close_stmt -> ; .)
    LEFTPAREN       reduce using rule 50 (close_stmt -> ; .)
    NEW             reduce using rule 50 (close_stmt -> ; .)
    INT_CONST       reduce using rule 50 (close_stmt -> ; .)
    FLOAT_CONST     reduce using rule 50 (close_stmt -> ; .)
    STRING_CONST    reduce using rule 50 (close_stmt -> ; .)
    NULL            reduce using rule 50 (close_stmt -> ; .)
    TRUE            reduce using rule 50 (close_stmt -> ; .)
    FALSE           reduce using rule 50 (close_stmt -> ; .)
    }               reduce using rule 50 (close_stmt -> ; .)
    ELSE            reduce using rule 50 (close_stmt -> ; .)


state 78

    (45) close_stmt -> RETURN . temp_9 ;
    (57) temp_9 -> . expr
    (58) temp_9 -> . empty
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (107) empty -> .
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    ;               reduce using rule 107 (empty -> .)
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    temp_9                         shift and go to state 123
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 79

    (46) close_stmt -> stmt_expr . ;

    ;               shift and go to state 126


state 80

    (47) close_stmt -> BREAK . ;

    ;               shift and go to state 127


state 81

    (48) close_stmt -> CONTINUE . ;

    ;               shift and go to state 128


state 82

    (49) close_stmt -> var_decl .

    IF              reduce using rule 49 (close_stmt -> var_decl .)
    WHILE           reduce using rule 49 (close_stmt -> var_decl .)
    FOR             reduce using rule 49 (close_stmt -> var_decl .)
    RETURN          reduce using rule 49 (close_stmt -> var_decl .)
    BREAK           reduce using rule 49 (close_stmt -> var_decl .)
    CONTINUE        reduce using rule 49 (close_stmt -> var_decl .)
    ;               reduce using rule 49 (close_stmt -> var_decl .)
    {               reduce using rule 49 (close_stmt -> var_decl .)
    INCREMENT       reduce using rule 49 (close_stmt -> var_decl .)
    DECREMENT       reduce using rule 49 (close_stmt -> var_decl .)
    INT             reduce using rule 49 (close_stmt -> var_decl .)
    FLOAT           reduce using rule 49 (close_stmt -> var_decl .)
    BOOLEAN         reduce using rule 49 (close_stmt -> var_decl .)
    ID              reduce using rule 49 (close_stmt -> var_decl .)
    THIS            reduce using rule 49 (close_stmt -> var_decl .)
    SUPER           reduce using rule 49 (close_stmt -> var_decl .)
    LEFTPAREN       reduce using rule 49 (close_stmt -> var_decl .)
    NEW             reduce using rule 49 (close_stmt -> var_decl .)
    INT_CONST       reduce using rule 49 (close_stmt -> var_decl .)
    FLOAT_CONST     reduce using rule 49 (close_stmt -> var_decl .)
    STRING_CONST    reduce using rule 49 (close_stmt -> var_decl .)
    NULL            reduce using rule 49 (close_stmt -> var_decl .)
    TRUE            reduce using rule 49 (close_stmt -> var_decl .)
    FALSE           reduce using rule 49 (close_stmt -> var_decl .)
    }               reduce using rule 49 (close_stmt -> var_decl .)
    ELSE            reduce using rule 49 (close_stmt -> var_decl .)


state 83

    (51) close_stmt -> block .

    IF              reduce using rule 51 (close_stmt -> block .)
    WHILE           reduce using rule 51 (close_stmt -> block .)
    FOR             reduce using rule 51 (close_stmt -> block .)
    RETURN          reduce using rule 51 (close_stmt -> block .)
    BREAK           reduce using rule 51 (close_stmt -> block .)
    CONTINUE        reduce using rule 51 (close_stmt -> block .)
    ;               reduce using rule 51 (close_stmt -> block .)
    {               reduce using rule 51 (close_stmt -> block .)
    INCREMENT       reduce using rule 51 (close_stmt -> block .)
    DECREMENT       reduce using rule 51 (close_stmt -> block .)
    INT             reduce using rule 51 (close_stmt -> block .)
    FLOAT           reduce using rule 51 (close_stmt -> block .)
    BOOLEAN         reduce using rule 51 (close_stmt -> block .)
    ID              reduce using rule 51 (close_stmt -> block .)
    THIS            reduce using rule 51 (close_stmt -> block .)
    SUPER           reduce using rule 51 (close_stmt -> block .)
    LEFTPAREN       reduce using rule 51 (close_stmt -> block .)
    NEW             reduce using rule 51 (close_stmt -> block .)
    INT_CONST       reduce using rule 51 (close_stmt -> block .)
    FLOAT_CONST     reduce using rule 51 (close_stmt -> block .)
    STRING_CONST    reduce using rule 51 (close_stmt -> block .)
    NULL            reduce using rule 51 (close_stmt -> block .)
    TRUE            reduce using rule 51 (close_stmt -> block .)
    FALSE           reduce using rule 51 (close_stmt -> block .)
    }               reduce using rule 51 (close_stmt -> block .)
    ELSE            reduce using rule 51 (close_stmt -> block .)


state 84

    (59) stmt_expr -> assign .

    ;               reduce using rule 59 (stmt_expr -> assign .)
    RIGHTPAREN      reduce using rule 59 (stmt_expr -> assign .)


state 85

    (60) stmt_expr -> method_invocation .
    (73) primary -> method_invocation .

    ;               reduce using rule 60 (stmt_expr -> method_invocation .)
    RIGHTPAREN      reduce using rule 60 (stmt_expr -> method_invocation .)
    .               reduce using rule 73 (primary -> method_invocation .)


state 86

    (19) var_decl -> type . variables ;
    (24) variables -> . variable temp_3
    (27) variable -> . ID

    ID              shift and go to state 54

    variables                      shift and go to state 36
    variable                       shift and go to state 37

state 87

    (87) assign -> lhs . = expr
    (88) assign -> lhs . INCREMENT
    (90) assign -> lhs . DECREMENT
    (72) primary -> lhs .

    =               shift and go to state 129
    INCREMENT       shift and go to state 130
    DECREMENT       shift and go to state 131
    .               reduce using rule 72 (primary -> lhs .)


state 88

    (89) assign -> INCREMENT . lhs
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN

    ID              shift and go to state 114
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    lhs                            shift and go to state 132
    field_access                   shift and go to state 120
    primary                        shift and go to state 92
    literal                        shift and go to state 93
    method_invocation              shift and go to state 116

state 89

    (91) assign -> DECREMENT . lhs
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN

    ID              shift and go to state 114
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    lhs                            shift and go to state 133
    field_access                   shift and go to state 120
    primary                        shift and go to state 92
    literal                        shift and go to state 93
    method_invocation              shift and go to state 116

state 90

    (81) method_invocation -> field_access . LEFTPAREN test_1 RIGHTPAREN
    (78) lhs -> field_access .

    LEFTPAREN       shift and go to state 134
    =               reduce using rule 78 (lhs -> field_access .)
    INCREMENT       reduce using rule 78 (lhs -> field_access .)
    DECREMENT       reduce using rule 78 (lhs -> field_access .)
    .               reduce using rule 78 (lhs -> field_access .)


state 91

    (23) type -> ID .
    (80) field_access -> ID .

    ID              reduce using rule 23 (type -> ID .)
    LEFTPAREN       reduce using rule 80 (field_access -> ID .)
    =               reduce using rule 80 (field_access -> ID .)
    INCREMENT       reduce using rule 80 (field_access -> ID .)
    DECREMENT       reduce using rule 80 (field_access -> ID .)
    .               reduce using rule 80 (field_access -> ID .)


state 92

    (79) field_access -> primary . . ID

    .               shift and go to state 135


state 93

    (67) primary -> literal .

    .               reduce using rule 67 (primary -> literal .)
    RIGHTPAREN      reduce using rule 67 (primary -> literal .)
    PLUS            reduce using rule 67 (primary -> literal .)
    MINUS           reduce using rule 67 (primary -> literal .)
    MULTIPLY        reduce using rule 67 (primary -> literal .)
    DIVIDE          reduce using rule 67 (primary -> literal .)
    BOOL_AND        reduce using rule 67 (primary -> literal .)
    BOOL_OR         reduce using rule 67 (primary -> literal .)
    EQUALITY        reduce using rule 67 (primary -> literal .)
    DISQUALITY      reduce using rule 67 (primary -> literal .)
    LESSTHAN        reduce using rule 67 (primary -> literal .)
    GREATERTHAN     reduce using rule 67 (primary -> literal .)
    LEQ             reduce using rule 67 (primary -> literal .)
    GEQ             reduce using rule 67 (primary -> literal .)
    ;               reduce using rule 67 (primary -> literal .)
    ,               reduce using rule 67 (primary -> literal .)


state 94

    (68) primary -> THIS .

    .               reduce using rule 68 (primary -> THIS .)
    RIGHTPAREN      reduce using rule 68 (primary -> THIS .)
    PLUS            reduce using rule 68 (primary -> THIS .)
    MINUS           reduce using rule 68 (primary -> THIS .)
    MULTIPLY        reduce using rule 68 (primary -> THIS .)
    DIVIDE          reduce using rule 68 (primary -> THIS .)
    BOOL_AND        reduce using rule 68 (primary -> THIS .)
    BOOL_OR         reduce using rule 68 (primary -> THIS .)
    EQUALITY        reduce using rule 68 (primary -> THIS .)
    DISQUALITY      reduce using rule 68 (primary -> THIS .)
    LESSTHAN        reduce using rule 68 (primary -> THIS .)
    GREATERTHAN     reduce using rule 68 (primary -> THIS .)
    LEQ             reduce using rule 68 (primary -> THIS .)
    GEQ             reduce using rule 68 (primary -> THIS .)
    ;               reduce using rule 68 (primary -> THIS .)
    ,               reduce using rule 68 (primary -> THIS .)


state 95

    (69) primary -> SUPER .

    .               reduce using rule 69 (primary -> SUPER .)
    RIGHTPAREN      reduce using rule 69 (primary -> SUPER .)
    PLUS            reduce using rule 69 (primary -> SUPER .)
    MINUS           reduce using rule 69 (primary -> SUPER .)
    MULTIPLY        reduce using rule 69 (primary -> SUPER .)
    DIVIDE          reduce using rule 69 (primary -> SUPER .)
    BOOL_AND        reduce using rule 69 (primary -> SUPER .)
    BOOL_OR         reduce using rule 69 (primary -> SUPER .)
    EQUALITY        reduce using rule 69 (primary -> SUPER .)
    DISQUALITY      reduce using rule 69 (primary -> SUPER .)
    LESSTHAN        reduce using rule 69 (primary -> SUPER .)
    GREATERTHAN     reduce using rule 69 (primary -> SUPER .)
    LEQ             reduce using rule 69 (primary -> SUPER .)
    GEQ             reduce using rule 69 (primary -> SUPER .)
    ;               reduce using rule 69 (primary -> SUPER .)
    ,               reduce using rule 69 (primary -> SUPER .)


state 96

    (71) primary -> NEW . ID LEFTPAREN test_1 RIGHTPAREN

    ID              shift and go to state 136


state 97

    (61) literal -> INT_CONST .

    .               reduce using rule 61 (literal -> INT_CONST .)
    RIGHTPAREN      reduce using rule 61 (literal -> INT_CONST .)
    PLUS            reduce using rule 61 (literal -> INT_CONST .)
    MINUS           reduce using rule 61 (literal -> INT_CONST .)
    MULTIPLY        reduce using rule 61 (literal -> INT_CONST .)
    DIVIDE          reduce using rule 61 (literal -> INT_CONST .)
    BOOL_AND        reduce using rule 61 (literal -> INT_CONST .)
    BOOL_OR         reduce using rule 61 (literal -> INT_CONST .)
    EQUALITY        reduce using rule 61 (literal -> INT_CONST .)
    DISQUALITY      reduce using rule 61 (literal -> INT_CONST .)
    LESSTHAN        reduce using rule 61 (literal -> INT_CONST .)
    GREATERTHAN     reduce using rule 61 (literal -> INT_CONST .)
    LEQ             reduce using rule 61 (literal -> INT_CONST .)
    GEQ             reduce using rule 61 (literal -> INT_CONST .)
    ;               reduce using rule 61 (literal -> INT_CONST .)
    ,               reduce using rule 61 (literal -> INT_CONST .)


state 98

    (62) literal -> FLOAT_CONST .

    .               reduce using rule 62 (literal -> FLOAT_CONST .)
    RIGHTPAREN      reduce using rule 62 (literal -> FLOAT_CONST .)
    PLUS            reduce using rule 62 (literal -> FLOAT_CONST .)
    MINUS           reduce using rule 62 (literal -> FLOAT_CONST .)
    MULTIPLY        reduce using rule 62 (literal -> FLOAT_CONST .)
    DIVIDE          reduce using rule 62 (literal -> FLOAT_CONST .)
    BOOL_AND        reduce using rule 62 (literal -> FLOAT_CONST .)
    BOOL_OR         reduce using rule 62 (literal -> FLOAT_CONST .)
    EQUALITY        reduce using rule 62 (literal -> FLOAT_CONST .)
    DISQUALITY      reduce using rule 62 (literal -> FLOAT_CONST .)
    LESSTHAN        reduce using rule 62 (literal -> FLOAT_CONST .)
    GREATERTHAN     reduce using rule 62 (literal -> FLOAT_CONST .)
    LEQ             reduce using rule 62 (literal -> FLOAT_CONST .)
    GEQ             reduce using rule 62 (literal -> FLOAT_CONST .)
    ;               reduce using rule 62 (literal -> FLOAT_CONST .)
    ,               reduce using rule 62 (literal -> FLOAT_CONST .)


state 99

    (63) literal -> STRING_CONST .

    .               reduce using rule 63 (literal -> STRING_CONST .)
    RIGHTPAREN      reduce using rule 63 (literal -> STRING_CONST .)
    PLUS            reduce using rule 63 (literal -> STRING_CONST .)
    MINUS           reduce using rule 63 (literal -> STRING_CONST .)
    MULTIPLY        reduce using rule 63 (literal -> STRING_CONST .)
    DIVIDE          reduce using rule 63 (literal -> STRING_CONST .)
    BOOL_AND        reduce using rule 63 (literal -> STRING_CONST .)
    BOOL_OR         reduce using rule 63 (literal -> STRING_CONST .)
    EQUALITY        reduce using rule 63 (literal -> STRING_CONST .)
    DISQUALITY      reduce using rule 63 (literal -> STRING_CONST .)
    LESSTHAN        reduce using rule 63 (literal -> STRING_CONST .)
    GREATERTHAN     reduce using rule 63 (literal -> STRING_CONST .)
    LEQ             reduce using rule 63 (literal -> STRING_CONST .)
    GEQ             reduce using rule 63 (literal -> STRING_CONST .)
    ;               reduce using rule 63 (literal -> STRING_CONST .)
    ,               reduce using rule 63 (literal -> STRING_CONST .)


state 100

    (64) literal -> NULL .

    .               reduce using rule 64 (literal -> NULL .)
    RIGHTPAREN      reduce using rule 64 (literal -> NULL .)
    PLUS            reduce using rule 64 (literal -> NULL .)
    MINUS           reduce using rule 64 (literal -> NULL .)
    MULTIPLY        reduce using rule 64 (literal -> NULL .)
    DIVIDE          reduce using rule 64 (literal -> NULL .)
    BOOL_AND        reduce using rule 64 (literal -> NULL .)
    BOOL_OR         reduce using rule 64 (literal -> NULL .)
    EQUALITY        reduce using rule 64 (literal -> NULL .)
    DISQUALITY      reduce using rule 64 (literal -> NULL .)
    LESSTHAN        reduce using rule 64 (literal -> NULL .)
    GREATERTHAN     reduce using rule 64 (literal -> NULL .)
    LEQ             reduce using rule 64 (literal -> NULL .)
    GEQ             reduce using rule 64 (literal -> NULL .)
    ;               reduce using rule 64 (literal -> NULL .)
    ,               reduce using rule 64 (literal -> NULL .)


state 101

    (65) literal -> TRUE .

    .               reduce using rule 65 (literal -> TRUE .)
    RIGHTPAREN      reduce using rule 65 (literal -> TRUE .)
    PLUS            reduce using rule 65 (literal -> TRUE .)
    MINUS           reduce using rule 65 (literal -> TRUE .)
    MULTIPLY        reduce using rule 65 (literal -> TRUE .)
    DIVIDE          reduce using rule 65 (literal -> TRUE .)
    BOOL_AND        reduce using rule 65 (literal -> TRUE .)
    BOOL_OR         reduce using rule 65 (literal -> TRUE .)
    EQUALITY        reduce using rule 65 (literal -> TRUE .)
    DISQUALITY      reduce using rule 65 (literal -> TRUE .)
    LESSTHAN        reduce using rule 65 (literal -> TRUE .)
    GREATERTHAN     reduce using rule 65 (literal -> TRUE .)
    LEQ             reduce using rule 65 (literal -> TRUE .)
    GEQ             reduce using rule 65 (literal -> TRUE .)
    ;               reduce using rule 65 (literal -> TRUE .)
    ,               reduce using rule 65 (literal -> TRUE .)


state 102

    (66) literal -> FALSE .

    .               reduce using rule 66 (literal -> FALSE .)
    RIGHTPAREN      reduce using rule 66 (literal -> FALSE .)
    PLUS            reduce using rule 66 (literal -> FALSE .)
    MINUS           reduce using rule 66 (literal -> FALSE .)
    MULTIPLY        reduce using rule 66 (literal -> FALSE .)
    DIVIDE          reduce using rule 66 (literal -> FALSE .)
    BOOL_AND        reduce using rule 66 (literal -> FALSE .)
    BOOL_OR         reduce using rule 66 (literal -> FALSE .)
    EQUALITY        reduce using rule 66 (literal -> FALSE .)
    DISQUALITY      reduce using rule 66 (literal -> FALSE .)
    LESSTHAN        reduce using rule 66 (literal -> FALSE .)
    GREATERTHAN     reduce using rule 66 (literal -> FALSE .)
    LEQ             reduce using rule 66 (literal -> FALSE .)
    GEQ             reduce using rule 66 (literal -> FALSE .)
    ;               reduce using rule 66 (literal -> FALSE .)
    ,               reduce using rule 66 (literal -> FALSE .)


state 103

    (33) temp_6 -> , formal_param temp_6 .

    RIGHTPAREN      reduce using rule 33 (temp_6 -> , formal_param temp_6 .)


state 104

    (29) method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .

    }               reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    PUBLIC          reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    PRIVATE         reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    STATIC          reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    VOID            reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    ID              reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    INT             reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    FLOAT           reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)
    BOOLEAN         reduce using rule 29 (method_decl -> modifier VOID ID LEFTPAREN formals RIGHTPAREN block .)


state 105

    (36) block -> { temp_7 } .

    }               reduce using rule 36 (block -> { temp_7 } .)
    PUBLIC          reduce using rule 36 (block -> { temp_7 } .)
    PRIVATE         reduce using rule 36 (block -> { temp_7 } .)
    STATIC          reduce using rule 36 (block -> { temp_7 } .)
    VOID            reduce using rule 36 (block -> { temp_7 } .)
    ID              reduce using rule 36 (block -> { temp_7 } .)
    INT             reduce using rule 36 (block -> { temp_7 } .)
    FLOAT           reduce using rule 36 (block -> { temp_7 } .)
    BOOLEAN         reduce using rule 36 (block -> { temp_7 } .)
    IF              reduce using rule 36 (block -> { temp_7 } .)
    WHILE           reduce using rule 36 (block -> { temp_7 } .)
    FOR             reduce using rule 36 (block -> { temp_7 } .)
    RETURN          reduce using rule 36 (block -> { temp_7 } .)
    BREAK           reduce using rule 36 (block -> { temp_7 } .)
    CONTINUE        reduce using rule 36 (block -> { temp_7 } .)
    ;               reduce using rule 36 (block -> { temp_7 } .)
    {               reduce using rule 36 (block -> { temp_7 } .)
    INCREMENT       reduce using rule 36 (block -> { temp_7 } .)
    DECREMENT       reduce using rule 36 (block -> { temp_7 } .)
    THIS            reduce using rule 36 (block -> { temp_7 } .)
    SUPER           reduce using rule 36 (block -> { temp_7 } .)
    LEFTPAREN       reduce using rule 36 (block -> { temp_7 } .)
    NEW             reduce using rule 36 (block -> { temp_7 } .)
    INT_CONST       reduce using rule 36 (block -> { temp_7 } .)
    FLOAT_CONST     reduce using rule 36 (block -> { temp_7 } .)
    STRING_CONST    reduce using rule 36 (block -> { temp_7 } .)
    NULL            reduce using rule 36 (block -> { temp_7 } .)
    TRUE            reduce using rule 36 (block -> { temp_7 } .)
    FALSE           reduce using rule 36 (block -> { temp_7 } .)
    ELSE            reduce using rule 36 (block -> { temp_7 } .)


state 106

    (37) temp_7 -> stmt temp_7 .

    }               reduce using rule 37 (temp_7 -> stmt temp_7 .)


state 107

    (41) open_stmt -> IF LEFTPAREN . expr RIGHTPAREN stmt
    (42) open_stmt -> IF LEFTPAREN . expr RIGHTPAREN close_stmt ELSE open_stmt
    (52) close_stmt -> IF LEFTPAREN . expr RIGHTPAREN close_stmt ELSE close_stmt
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 137
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 108

    (70) primary -> LEFTPAREN expr . RIGHTPAREN
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      shift and go to state 138
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150


state 109

    (82) expr -> primary .
    (79) field_access -> primary . . ID

    RIGHTPAREN      reduce using rule 82 (expr -> primary .)
    PLUS            reduce using rule 82 (expr -> primary .)
    MINUS           reduce using rule 82 (expr -> primary .)
    MULTIPLY        reduce using rule 82 (expr -> primary .)
    DIVIDE          reduce using rule 82 (expr -> primary .)
    BOOL_AND        reduce using rule 82 (expr -> primary .)
    BOOL_OR         reduce using rule 82 (expr -> primary .)
    EQUALITY        reduce using rule 82 (expr -> primary .)
    DISQUALITY      reduce using rule 82 (expr -> primary .)
    LESSTHAN        reduce using rule 82 (expr -> primary .)
    GREATERTHAN     reduce using rule 82 (expr -> primary .)
    LEQ             reduce using rule 82 (expr -> primary .)
    GEQ             reduce using rule 82 (expr -> primary .)
    ;               reduce using rule 82 (expr -> primary .)
    ,               reduce using rule 82 (expr -> primary .)
    .               shift and go to state 135


state 110

    (83) expr -> assign .

    RIGHTPAREN      reduce using rule 83 (expr -> assign .)
    PLUS            reduce using rule 83 (expr -> assign .)
    MINUS           reduce using rule 83 (expr -> assign .)
    MULTIPLY        reduce using rule 83 (expr -> assign .)
    DIVIDE          reduce using rule 83 (expr -> assign .)
    BOOL_AND        reduce using rule 83 (expr -> assign .)
    BOOL_OR         reduce using rule 83 (expr -> assign .)
    EQUALITY        reduce using rule 83 (expr -> assign .)
    DISQUALITY      reduce using rule 83 (expr -> assign .)
    LESSTHAN        reduce using rule 83 (expr -> assign .)
    GREATERTHAN     reduce using rule 83 (expr -> assign .)
    LEQ             reduce using rule 83 (expr -> assign .)
    GEQ             reduce using rule 83 (expr -> assign .)
    ;               reduce using rule 83 (expr -> assign .)
    ,               reduce using rule 83 (expr -> assign .)


state 111

    (84) expr -> arith_op .

    RIGHTPAREN      reduce using rule 84 (expr -> arith_op .)
    PLUS            reduce using rule 84 (expr -> arith_op .)
    MINUS           reduce using rule 84 (expr -> arith_op .)
    MULTIPLY        reduce using rule 84 (expr -> arith_op .)
    DIVIDE          reduce using rule 84 (expr -> arith_op .)
    BOOL_AND        reduce using rule 84 (expr -> arith_op .)
    BOOL_OR         reduce using rule 84 (expr -> arith_op .)
    EQUALITY        reduce using rule 84 (expr -> arith_op .)
    DISQUALITY      reduce using rule 84 (expr -> arith_op .)
    LESSTHAN        reduce using rule 84 (expr -> arith_op .)
    GREATERTHAN     reduce using rule 84 (expr -> arith_op .)
    LEQ             reduce using rule 84 (expr -> arith_op .)
    GEQ             reduce using rule 84 (expr -> arith_op .)
    ;               reduce using rule 84 (expr -> arith_op .)
    ,               reduce using rule 84 (expr -> arith_op .)


state 112

    (85) expr -> bool_op .

    RIGHTPAREN      reduce using rule 85 (expr -> bool_op .)
    PLUS            reduce using rule 85 (expr -> bool_op .)
    MINUS           reduce using rule 85 (expr -> bool_op .)
    MULTIPLY        reduce using rule 85 (expr -> bool_op .)
    DIVIDE          reduce using rule 85 (expr -> bool_op .)
    BOOL_AND        reduce using rule 85 (expr -> bool_op .)
    BOOL_OR         reduce using rule 85 (expr -> bool_op .)
    EQUALITY        reduce using rule 85 (expr -> bool_op .)
    DISQUALITY      reduce using rule 85 (expr -> bool_op .)
    LESSTHAN        reduce using rule 85 (expr -> bool_op .)
    GREATERTHAN     reduce using rule 85 (expr -> bool_op .)
    LEQ             reduce using rule 85 (expr -> bool_op .)
    GEQ             reduce using rule 85 (expr -> bool_op .)
    ;               reduce using rule 85 (expr -> bool_op .)
    ,               reduce using rule 85 (expr -> bool_op .)


state 113

    (86) expr -> unary_op .

    RIGHTPAREN      reduce using rule 86 (expr -> unary_op .)
    PLUS            reduce using rule 86 (expr -> unary_op .)
    MINUS           reduce using rule 86 (expr -> unary_op .)
    MULTIPLY        reduce using rule 86 (expr -> unary_op .)
    DIVIDE          reduce using rule 86 (expr -> unary_op .)
    BOOL_AND        reduce using rule 86 (expr -> unary_op .)
    BOOL_OR         reduce using rule 86 (expr -> unary_op .)
    EQUALITY        reduce using rule 86 (expr -> unary_op .)
    DISQUALITY      reduce using rule 86 (expr -> unary_op .)
    LESSTHAN        reduce using rule 86 (expr -> unary_op .)
    GREATERTHAN     reduce using rule 86 (expr -> unary_op .)
    LEQ             reduce using rule 86 (expr -> unary_op .)
    GEQ             reduce using rule 86 (expr -> unary_op .)
    ;               reduce using rule 86 (expr -> unary_op .)
    ,               reduce using rule 86 (expr -> unary_op .)


state 114

    (80) field_access -> ID .

    LEFTPAREN       reduce using rule 80 (field_access -> ID .)
    =               reduce using rule 80 (field_access -> ID .)
    INCREMENT       reduce using rule 80 (field_access -> ID .)
    DECREMENT       reduce using rule 80 (field_access -> ID .)
    .               reduce using rule 80 (field_access -> ID .)
    RIGHTPAREN      reduce using rule 80 (field_access -> ID .)
    PLUS            reduce using rule 80 (field_access -> ID .)
    MINUS           reduce using rule 80 (field_access -> ID .)
    MULTIPLY        reduce using rule 80 (field_access -> ID .)
    DIVIDE          reduce using rule 80 (field_access -> ID .)
    BOOL_AND        reduce using rule 80 (field_access -> ID .)
    BOOL_OR         reduce using rule 80 (field_access -> ID .)
    EQUALITY        reduce using rule 80 (field_access -> ID .)
    DISQUALITY      reduce using rule 80 (field_access -> ID .)
    LESSTHAN        reduce using rule 80 (field_access -> ID .)
    GREATERTHAN     reduce using rule 80 (field_access -> ID .)
    LEQ             reduce using rule 80 (field_access -> ID .)
    GEQ             reduce using rule 80 (field_access -> ID .)
    ;               reduce using rule 80 (field_access -> ID .)
    ,               reduce using rule 80 (field_access -> ID .)


state 115

    (72) primary -> lhs .
    (87) assign -> lhs . = expr
    (88) assign -> lhs . INCREMENT
    (90) assign -> lhs . DECREMENT

    .               reduce using rule 72 (primary -> lhs .)
    RIGHTPAREN      reduce using rule 72 (primary -> lhs .)
    PLUS            reduce using rule 72 (primary -> lhs .)
    MINUS           reduce using rule 72 (primary -> lhs .)
    MULTIPLY        reduce using rule 72 (primary -> lhs .)
    DIVIDE          reduce using rule 72 (primary -> lhs .)
    BOOL_AND        reduce using rule 72 (primary -> lhs .)
    BOOL_OR         reduce using rule 72 (primary -> lhs .)
    EQUALITY        reduce using rule 72 (primary -> lhs .)
    DISQUALITY      reduce using rule 72 (primary -> lhs .)
    LESSTHAN        reduce using rule 72 (primary -> lhs .)
    GREATERTHAN     reduce using rule 72 (primary -> lhs .)
    LEQ             reduce using rule 72 (primary -> lhs .)
    GEQ             reduce using rule 72 (primary -> lhs .)
    ;               reduce using rule 72 (primary -> lhs .)
    ,               reduce using rule 72 (primary -> lhs .)
    =               shift and go to state 129
    INCREMENT       shift and go to state 130
    DECREMENT       shift and go to state 131


state 116

    (73) primary -> method_invocation .

    .               reduce using rule 73 (primary -> method_invocation .)
    RIGHTPAREN      reduce using rule 73 (primary -> method_invocation .)
    PLUS            reduce using rule 73 (primary -> method_invocation .)
    MINUS           reduce using rule 73 (primary -> method_invocation .)
    MULTIPLY        reduce using rule 73 (primary -> method_invocation .)
    DIVIDE          reduce using rule 73 (primary -> method_invocation .)
    BOOL_AND        reduce using rule 73 (primary -> method_invocation .)
    BOOL_OR         reduce using rule 73 (primary -> method_invocation .)
    EQUALITY        reduce using rule 73 (primary -> method_invocation .)
    DISQUALITY      reduce using rule 73 (primary -> method_invocation .)
    LESSTHAN        reduce using rule 73 (primary -> method_invocation .)
    GREATERTHAN     reduce using rule 73 (primary -> method_invocation .)
    LEQ             reduce using rule 73 (primary -> method_invocation .)
    GEQ             reduce using rule 73 (primary -> method_invocation .)
    ;               reduce using rule 73 (primary -> method_invocation .)
    ,               reduce using rule 73 (primary -> method_invocation .)


state 117

    (104) unary_op -> PLUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 151
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 118

    (105) unary_op -> MINUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 152
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 119

    (106) unary_op -> NOT . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 153
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 120

    (78) lhs -> field_access .
    (81) method_invocation -> field_access . LEFTPAREN test_1 RIGHTPAREN

    =               reduce using rule 78 (lhs -> field_access .)
    INCREMENT       reduce using rule 78 (lhs -> field_access .)
    DECREMENT       reduce using rule 78 (lhs -> field_access .)
    .               reduce using rule 78 (lhs -> field_access .)
    RIGHTPAREN      reduce using rule 78 (lhs -> field_access .)
    PLUS            reduce using rule 78 (lhs -> field_access .)
    MINUS           reduce using rule 78 (lhs -> field_access .)
    MULTIPLY        reduce using rule 78 (lhs -> field_access .)
    DIVIDE          reduce using rule 78 (lhs -> field_access .)
    BOOL_AND        reduce using rule 78 (lhs -> field_access .)
    BOOL_OR         reduce using rule 78 (lhs -> field_access .)
    EQUALITY        reduce using rule 78 (lhs -> field_access .)
    DISQUALITY      reduce using rule 78 (lhs -> field_access .)
    LESSTHAN        reduce using rule 78 (lhs -> field_access .)
    GREATERTHAN     reduce using rule 78 (lhs -> field_access .)
    LEQ             reduce using rule 78 (lhs -> field_access .)
    GEQ             reduce using rule 78 (lhs -> field_access .)
    ;               reduce using rule 78 (lhs -> field_access .)
    ,               reduce using rule 78 (lhs -> field_access .)
    LEFTPAREN       shift and go to state 134


state 121

    (43) open_stmt -> WHILE LEFTPAREN . expr RIGHTPAREN open_stmt
    (53) close_stmt -> WHILE LEFTPAREN . expr RIGHTPAREN close_stmt
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 154
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 122

    (44) open_stmt -> FOR LEFTPAREN . temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (54) close_stmt -> FOR LEFTPAREN . temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (55) temp_8 -> . stmt_expr
    (56) temp_8 -> . empty
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (107) empty -> .
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    ;               reduce using rule 107 (empty -> .)
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    ID              shift and go to state 114
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    temp_8                         shift and go to state 155
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 123

    (45) close_stmt -> RETURN temp_9 . ;

    ;               shift and go to state 158


state 124

    (57) temp_9 -> expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    ;               reduce using rule 57 (temp_9 -> expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150


state 125

    (58) temp_9 -> empty .

    ;               reduce using rule 58 (temp_9 -> empty .)


state 126

    (46) close_stmt -> stmt_expr ; .

    IF              reduce using rule 46 (close_stmt -> stmt_expr ; .)
    WHILE           reduce using rule 46 (close_stmt -> stmt_expr ; .)
    FOR             reduce using rule 46 (close_stmt -> stmt_expr ; .)
    RETURN          reduce using rule 46 (close_stmt -> stmt_expr ; .)
    BREAK           reduce using rule 46 (close_stmt -> stmt_expr ; .)
    CONTINUE        reduce using rule 46 (close_stmt -> stmt_expr ; .)
    ;               reduce using rule 46 (close_stmt -> stmt_expr ; .)
    {               reduce using rule 46 (close_stmt -> stmt_expr ; .)
    INCREMENT       reduce using rule 46 (close_stmt -> stmt_expr ; .)
    DECREMENT       reduce using rule 46 (close_stmt -> stmt_expr ; .)
    INT             reduce using rule 46 (close_stmt -> stmt_expr ; .)
    FLOAT           reduce using rule 46 (close_stmt -> stmt_expr ; .)
    BOOLEAN         reduce using rule 46 (close_stmt -> stmt_expr ; .)
    ID              reduce using rule 46 (close_stmt -> stmt_expr ; .)
    THIS            reduce using rule 46 (close_stmt -> stmt_expr ; .)
    SUPER           reduce using rule 46 (close_stmt -> stmt_expr ; .)
    LEFTPAREN       reduce using rule 46 (close_stmt -> stmt_expr ; .)
    NEW             reduce using rule 46 (close_stmt -> stmt_expr ; .)
    INT_CONST       reduce using rule 46 (close_stmt -> stmt_expr ; .)
    FLOAT_CONST     reduce using rule 46 (close_stmt -> stmt_expr ; .)
    STRING_CONST    reduce using rule 46 (close_stmt -> stmt_expr ; .)
    NULL            reduce using rule 46 (close_stmt -> stmt_expr ; .)
    TRUE            reduce using rule 46 (close_stmt -> stmt_expr ; .)
    FALSE           reduce using rule 46 (close_stmt -> stmt_expr ; .)
    }               reduce using rule 46 (close_stmt -> stmt_expr ; .)
    ELSE            reduce using rule 46 (close_stmt -> stmt_expr ; .)


state 127

    (47) close_stmt -> BREAK ; .

    IF              reduce using rule 47 (close_stmt -> BREAK ; .)
    WHILE           reduce using rule 47 (close_stmt -> BREAK ; .)
    FOR             reduce using rule 47 (close_stmt -> BREAK ; .)
    RETURN          reduce using rule 47 (close_stmt -> BREAK ; .)
    BREAK           reduce using rule 47 (close_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 47 (close_stmt -> BREAK ; .)
    ;               reduce using rule 47 (close_stmt -> BREAK ; .)
    {               reduce using rule 47 (close_stmt -> BREAK ; .)
    INCREMENT       reduce using rule 47 (close_stmt -> BREAK ; .)
    DECREMENT       reduce using rule 47 (close_stmt -> BREAK ; .)
    INT             reduce using rule 47 (close_stmt -> BREAK ; .)
    FLOAT           reduce using rule 47 (close_stmt -> BREAK ; .)
    BOOLEAN         reduce using rule 47 (close_stmt -> BREAK ; .)
    ID              reduce using rule 47 (close_stmt -> BREAK ; .)
    THIS            reduce using rule 47 (close_stmt -> BREAK ; .)
    SUPER           reduce using rule 47 (close_stmt -> BREAK ; .)
    LEFTPAREN       reduce using rule 47 (close_stmt -> BREAK ; .)
    NEW             reduce using rule 47 (close_stmt -> BREAK ; .)
    INT_CONST       reduce using rule 47 (close_stmt -> BREAK ; .)
    FLOAT_CONST     reduce using rule 47 (close_stmt -> BREAK ; .)
    STRING_CONST    reduce using rule 47 (close_stmt -> BREAK ; .)
    NULL            reduce using rule 47 (close_stmt -> BREAK ; .)
    TRUE            reduce using rule 47 (close_stmt -> BREAK ; .)
    FALSE           reduce using rule 47 (close_stmt -> BREAK ; .)
    }               reduce using rule 47 (close_stmt -> BREAK ; .)
    ELSE            reduce using rule 47 (close_stmt -> BREAK ; .)


state 128

    (48) close_stmt -> CONTINUE ; .

    IF              reduce using rule 48 (close_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 48 (close_stmt -> CONTINUE ; .)
    FOR             reduce using rule 48 (close_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 48 (close_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 48 (close_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 48 (close_stmt -> CONTINUE ; .)
    ;               reduce using rule 48 (close_stmt -> CONTINUE ; .)
    {               reduce using rule 48 (close_stmt -> CONTINUE ; .)
    INCREMENT       reduce using rule 48 (close_stmt -> CONTINUE ; .)
    DECREMENT       reduce using rule 48 (close_stmt -> CONTINUE ; .)
    INT             reduce using rule 48 (close_stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 48 (close_stmt -> CONTINUE ; .)
    BOOLEAN         reduce using rule 48 (close_stmt -> CONTINUE ; .)
    ID              reduce using rule 48 (close_stmt -> CONTINUE ; .)
    THIS            reduce using rule 48 (close_stmt -> CONTINUE ; .)
    SUPER           reduce using rule 48 (close_stmt -> CONTINUE ; .)
    LEFTPAREN       reduce using rule 48 (close_stmt -> CONTINUE ; .)
    NEW             reduce using rule 48 (close_stmt -> CONTINUE ; .)
    INT_CONST       reduce using rule 48 (close_stmt -> CONTINUE ; .)
    FLOAT_CONST     reduce using rule 48 (close_stmt -> CONTINUE ; .)
    STRING_CONST    reduce using rule 48 (close_stmt -> CONTINUE ; .)
    NULL            reduce using rule 48 (close_stmt -> CONTINUE ; .)
    TRUE            reduce using rule 48 (close_stmt -> CONTINUE ; .)
    FALSE           reduce using rule 48 (close_stmt -> CONTINUE ; .)
    }               reduce using rule 48 (close_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 48 (close_stmt -> CONTINUE ; .)


state 129

    (87) assign -> lhs = . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    lhs                            shift and go to state 115
    expr                           shift and go to state 159
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 130

    (88) assign -> lhs INCREMENT .

    ;               reduce using rule 88 (assign -> lhs INCREMENT .)
    RIGHTPAREN      reduce using rule 88 (assign -> lhs INCREMENT .)
    PLUS            reduce using rule 88 (assign -> lhs INCREMENT .)
    MINUS           reduce using rule 88 (assign -> lhs INCREMENT .)
    MULTIPLY        reduce using rule 88 (assign -> lhs INCREMENT .)
    DIVIDE          reduce using rule 88 (assign -> lhs INCREMENT .)
    BOOL_AND        reduce using rule 88 (assign -> lhs INCREMENT .)
    BOOL_OR         reduce using rule 88 (assign -> lhs INCREMENT .)
    EQUALITY        reduce using rule 88 (assign -> lhs INCREMENT .)
    DISQUALITY      reduce using rule 88 (assign -> lhs INCREMENT .)
    LESSTHAN        reduce using rule 88 (assign -> lhs INCREMENT .)
    GREATERTHAN     reduce using rule 88 (assign -> lhs INCREMENT .)
    LEQ             reduce using rule 88 (assign -> lhs INCREMENT .)
    GEQ             reduce using rule 88 (assign -> lhs INCREMENT .)
    ,               reduce using rule 88 (assign -> lhs INCREMENT .)


state 131

    (90) assign -> lhs DECREMENT .

    ;               reduce using rule 90 (assign -> lhs DECREMENT .)
    RIGHTPAREN      reduce using rule 90 (assign -> lhs DECREMENT .)
    PLUS            reduce using rule 90 (assign -> lhs DECREMENT .)
    MINUS           reduce using rule 90 (assign -> lhs DECREMENT .)
    MULTIPLY        reduce using rule 90 (assign -> lhs DECREMENT .)
    DIVIDE          reduce using rule 90 (assign -> lhs DECREMENT .)
    BOOL_AND        reduce using rule 90 (assign -> lhs DECREMENT .)
    BOOL_OR         reduce using rule 90 (assign -> lhs DECREMENT .)
    EQUALITY        reduce using rule 90 (assign -> lhs DECREMENT .)
    DISQUALITY      reduce using rule 90 (assign -> lhs DECREMENT .)
    LESSTHAN        reduce using rule 90 (assign -> lhs DECREMENT .)
    GREATERTHAN     reduce using rule 90 (assign -> lhs DECREMENT .)
    LEQ             reduce using rule 90 (assign -> lhs DECREMENT .)
    GEQ             reduce using rule 90 (assign -> lhs DECREMENT .)
    ,               reduce using rule 90 (assign -> lhs DECREMENT .)


state 132

    (89) assign -> INCREMENT lhs .
    (72) primary -> lhs .

    ;               reduce using rule 89 (assign -> INCREMENT lhs .)
    RIGHTPAREN      reduce using rule 89 (assign -> INCREMENT lhs .)
    PLUS            reduce using rule 89 (assign -> INCREMENT lhs .)
    MINUS           reduce using rule 89 (assign -> INCREMENT lhs .)
    MULTIPLY        reduce using rule 89 (assign -> INCREMENT lhs .)
    DIVIDE          reduce using rule 89 (assign -> INCREMENT lhs .)
    BOOL_AND        reduce using rule 89 (assign -> INCREMENT lhs .)
    BOOL_OR         reduce using rule 89 (assign -> INCREMENT lhs .)
    EQUALITY        reduce using rule 89 (assign -> INCREMENT lhs .)
    DISQUALITY      reduce using rule 89 (assign -> INCREMENT lhs .)
    LESSTHAN        reduce using rule 89 (assign -> INCREMENT lhs .)
    GREATERTHAN     reduce using rule 89 (assign -> INCREMENT lhs .)
    LEQ             reduce using rule 89 (assign -> INCREMENT lhs .)
    GEQ             reduce using rule 89 (assign -> INCREMENT lhs .)
    ,               reduce using rule 89 (assign -> INCREMENT lhs .)
    .               reduce using rule 72 (primary -> lhs .)


state 133

    (91) assign -> DECREMENT lhs .
    (72) primary -> lhs .

    ;               reduce using rule 91 (assign -> DECREMENT lhs .)
    RIGHTPAREN      reduce using rule 91 (assign -> DECREMENT lhs .)
    PLUS            reduce using rule 91 (assign -> DECREMENT lhs .)
    MINUS           reduce using rule 91 (assign -> DECREMENT lhs .)
    MULTIPLY        reduce using rule 91 (assign -> DECREMENT lhs .)
    DIVIDE          reduce using rule 91 (assign -> DECREMENT lhs .)
    BOOL_AND        reduce using rule 91 (assign -> DECREMENT lhs .)
    BOOL_OR         reduce using rule 91 (assign -> DECREMENT lhs .)
    EQUALITY        reduce using rule 91 (assign -> DECREMENT lhs .)
    DISQUALITY      reduce using rule 91 (assign -> DECREMENT lhs .)
    LESSTHAN        reduce using rule 91 (assign -> DECREMENT lhs .)
    GREATERTHAN     reduce using rule 91 (assign -> DECREMENT lhs .)
    LEQ             reduce using rule 91 (assign -> DECREMENT lhs .)
    GEQ             reduce using rule 91 (assign -> DECREMENT lhs .)
    ,               reduce using rule 91 (assign -> DECREMENT lhs .)
    .               reduce using rule 72 (primary -> lhs .)


state 134

    (81) method_invocation -> field_access LEFTPAREN . test_1 RIGHTPAREN
    (74) test_1 -> . expr test_2
    (75) test_1 -> . empty
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (107) empty -> .
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    field_access                   shift and go to state 120
    test_1                         shift and go to state 160
    expr                           shift and go to state 161
    empty                          shift and go to state 162
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116

state 135

    (79) field_access -> primary . . ID

    ID              shift and go to state 163


state 136

    (71) primary -> NEW ID . LEFTPAREN test_1 RIGHTPAREN

    LEFTPAREN       shift and go to state 164


state 137

    (41) open_stmt -> IF LEFTPAREN expr . RIGHTPAREN stmt
    (42) open_stmt -> IF LEFTPAREN expr . RIGHTPAREN close_stmt ELSE open_stmt
    (52) close_stmt -> IF LEFTPAREN expr . RIGHTPAREN close_stmt ELSE close_stmt
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      shift and go to state 165
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150


state 138

    (70) primary -> LEFTPAREN expr RIGHTPAREN .

    .               reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    RIGHTPAREN      reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    PLUS            reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    MINUS           reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    MULTIPLY        reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    DIVIDE          reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    BOOL_AND        reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    BOOL_OR         reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    EQUALITY        reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    DISQUALITY      reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    LESSTHAN        reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    GREATERTHAN     reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    LEQ             reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    GEQ             reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    ;               reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)
    ,               reduce using rule 70 (primary -> LEFTPAREN expr RIGHTPAREN .)


state 139

    (92) arith_op -> expr PLUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 166
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 140

    (93) arith_op -> expr MINUS . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 167
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 141

    (94) arith_op -> expr MULTIPLY . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 168
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 142

    (95) arith_op -> expr DIVIDE . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 169
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 143

    (96) bool_op -> expr BOOL_AND . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 170
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 144

    (97) bool_op -> expr BOOL_OR . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 171
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 145

    (98) bool_op -> expr EQUALITY . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 172
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 146

    (99) bool_op -> expr DISQUALITY . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 173
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 147

    (100) bool_op -> expr LESSTHAN . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 174
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 148

    (101) bool_op -> expr GREATERTHAN . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 175
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 149

    (102) bool_op -> expr LEQ . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 176
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 150

    (103) bool_op -> expr GEQ . expr
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 177
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 151

    (104) unary_op -> PLUS expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 104 (unary_op -> PLUS expr .)
    PLUS            reduce using rule 104 (unary_op -> PLUS expr .)
    MINUS           reduce using rule 104 (unary_op -> PLUS expr .)
    MULTIPLY        reduce using rule 104 (unary_op -> PLUS expr .)
    DIVIDE          reduce using rule 104 (unary_op -> PLUS expr .)
    BOOL_AND        reduce using rule 104 (unary_op -> PLUS expr .)
    BOOL_OR         reduce using rule 104 (unary_op -> PLUS expr .)
    EQUALITY        reduce using rule 104 (unary_op -> PLUS expr .)
    DISQUALITY      reduce using rule 104 (unary_op -> PLUS expr .)
    LESSTHAN        reduce using rule 104 (unary_op -> PLUS expr .)
    GREATERTHAN     reduce using rule 104 (unary_op -> PLUS expr .)
    LEQ             reduce using rule 104 (unary_op -> PLUS expr .)
    GEQ             reduce using rule 104 (unary_op -> PLUS expr .)
    ;               reduce using rule 104 (unary_op -> PLUS expr .)
    ,               reduce using rule 104 (unary_op -> PLUS expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 152

    (105) unary_op -> MINUS expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 105 (unary_op -> MINUS expr .)
    PLUS            reduce using rule 105 (unary_op -> MINUS expr .)
    MINUS           reduce using rule 105 (unary_op -> MINUS expr .)
    MULTIPLY        reduce using rule 105 (unary_op -> MINUS expr .)
    DIVIDE          reduce using rule 105 (unary_op -> MINUS expr .)
    BOOL_AND        reduce using rule 105 (unary_op -> MINUS expr .)
    BOOL_OR         reduce using rule 105 (unary_op -> MINUS expr .)
    EQUALITY        reduce using rule 105 (unary_op -> MINUS expr .)
    DISQUALITY      reduce using rule 105 (unary_op -> MINUS expr .)
    LESSTHAN        reduce using rule 105 (unary_op -> MINUS expr .)
    GREATERTHAN     reduce using rule 105 (unary_op -> MINUS expr .)
    LEQ             reduce using rule 105 (unary_op -> MINUS expr .)
    GEQ             reduce using rule 105 (unary_op -> MINUS expr .)
    ;               reduce using rule 105 (unary_op -> MINUS expr .)
    ,               reduce using rule 105 (unary_op -> MINUS expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 153

    (106) unary_op -> NOT expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 106 (unary_op -> NOT expr .)
    PLUS            reduce using rule 106 (unary_op -> NOT expr .)
    MINUS           reduce using rule 106 (unary_op -> NOT expr .)
    MULTIPLY        reduce using rule 106 (unary_op -> NOT expr .)
    DIVIDE          reduce using rule 106 (unary_op -> NOT expr .)
    BOOL_AND        reduce using rule 106 (unary_op -> NOT expr .)
    BOOL_OR         reduce using rule 106 (unary_op -> NOT expr .)
    EQUALITY        reduce using rule 106 (unary_op -> NOT expr .)
    DISQUALITY      reduce using rule 106 (unary_op -> NOT expr .)
    LESSTHAN        reduce using rule 106 (unary_op -> NOT expr .)
    GREATERTHAN     reduce using rule 106 (unary_op -> NOT expr .)
    LEQ             reduce using rule 106 (unary_op -> NOT expr .)
    GEQ             reduce using rule 106 (unary_op -> NOT expr .)
    ;               reduce using rule 106 (unary_op -> NOT expr .)
    ,               reduce using rule 106 (unary_op -> NOT expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 154

    (43) open_stmt -> WHILE LEFTPAREN expr . RIGHTPAREN open_stmt
    (53) close_stmt -> WHILE LEFTPAREN expr . RIGHTPAREN close_stmt
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      shift and go to state 178
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150


state 155

    (44) open_stmt -> FOR LEFTPAREN temp_8 . ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (54) close_stmt -> FOR LEFTPAREN temp_8 . ; temp_9 ; temp_8 RIGHTPAREN close_stmt

    ;               shift and go to state 179


state 156

    (55) temp_8 -> stmt_expr .

    ;               reduce using rule 55 (temp_8 -> stmt_expr .)
    RIGHTPAREN      reduce using rule 55 (temp_8 -> stmt_expr .)


state 157

    (56) temp_8 -> empty .

    ;               reduce using rule 56 (temp_8 -> empty .)
    RIGHTPAREN      reduce using rule 56 (temp_8 -> empty .)


state 158

    (45) close_stmt -> RETURN temp_9 ; .

    IF              reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    WHILE           reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    FOR             reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    RETURN          reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    BREAK           reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    CONTINUE        reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    ;               reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    {               reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    INCREMENT       reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    DECREMENT       reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    INT             reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    FLOAT           reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    BOOLEAN         reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    ID              reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    THIS            reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    SUPER           reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    LEFTPAREN       reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    NEW             reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    INT_CONST       reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    FLOAT_CONST     reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    STRING_CONST    reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    NULL            reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    TRUE            reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    FALSE           reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    }               reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)
    ELSE            reduce using rule 45 (close_stmt -> RETURN temp_9 ; .)


state 159

    (87) assign -> lhs = expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    ;               reduce using rule 87 (assign -> lhs = expr .)
    RIGHTPAREN      reduce using rule 87 (assign -> lhs = expr .)
    ,               reduce using rule 87 (assign -> lhs = expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150

  ! PLUS            [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! MINUS           [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! MULTIPLY        [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! DIVIDE          [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! BOOL_AND        [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! BOOL_OR         [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! EQUALITY        [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! DISQUALITY      [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! LESSTHAN        [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! GREATERTHAN     [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! LEQ             [ reduce using rule 87 (assign -> lhs = expr .) ]
  ! GEQ             [ reduce using rule 87 (assign -> lhs = expr .) ]


state 160

    (81) method_invocation -> field_access LEFTPAREN test_1 . RIGHTPAREN

    RIGHTPAREN      shift and go to state 180


state 161

    (74) test_1 -> expr . test_2
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr
    (76) test_2 -> . , expr test_2
    (77) test_2 -> . empty
    (107) empty -> .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150
    ,               shift and go to state 182
    RIGHTPAREN      reduce using rule 107 (empty -> .)

    test_2                         shift and go to state 181
    empty                          shift and go to state 183

state 162

    (75) test_1 -> empty .

    RIGHTPAREN      reduce using rule 75 (test_1 -> empty .)


state 163

    (79) field_access -> primary . ID .

    LEFTPAREN       reduce using rule 79 (field_access -> primary . ID .)
    =               reduce using rule 79 (field_access -> primary . ID .)
    INCREMENT       reduce using rule 79 (field_access -> primary . ID .)
    DECREMENT       reduce using rule 79 (field_access -> primary . ID .)
    .               reduce using rule 79 (field_access -> primary . ID .)
    RIGHTPAREN      reduce using rule 79 (field_access -> primary . ID .)
    PLUS            reduce using rule 79 (field_access -> primary . ID .)
    MINUS           reduce using rule 79 (field_access -> primary . ID .)
    MULTIPLY        reduce using rule 79 (field_access -> primary . ID .)
    DIVIDE          reduce using rule 79 (field_access -> primary . ID .)
    BOOL_AND        reduce using rule 79 (field_access -> primary . ID .)
    BOOL_OR         reduce using rule 79 (field_access -> primary . ID .)
    EQUALITY        reduce using rule 79 (field_access -> primary . ID .)
    DISQUALITY      reduce using rule 79 (field_access -> primary . ID .)
    LESSTHAN        reduce using rule 79 (field_access -> primary . ID .)
    GREATERTHAN     reduce using rule 79 (field_access -> primary . ID .)
    LEQ             reduce using rule 79 (field_access -> primary . ID .)
    GEQ             reduce using rule 79 (field_access -> primary . ID .)
    ;               reduce using rule 79 (field_access -> primary . ID .)
    ,               reduce using rule 79 (field_access -> primary . ID .)


state 164

    (71) primary -> NEW ID LEFTPAREN . test_1 RIGHTPAREN
    (74) test_1 -> . expr test_2
    (75) test_1 -> . empty
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (107) empty -> .
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    test_1                         shift and go to state 184
    expr                           shift and go to state 161
    empty                          shift and go to state 162
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 165

    (41) open_stmt -> IF LEFTPAREN expr RIGHTPAREN . stmt
    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN . close_stmt ELSE open_stmt
    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN . close_stmt ELSE close_stmt
    (39) stmt -> . open_stmt
    (40) stmt -> . close_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    IF              shift and go to state 185
    WHILE           shift and go to state 188
    FOR             shift and go to state 189
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    stmt                           shift and go to state 186
    close_stmt                     shift and go to state 187
    open_stmt                      shift and go to state 71
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 166

    (92) arith_op -> expr PLUS expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 92 (arith_op -> expr PLUS expr .)
    PLUS            reduce using rule 92 (arith_op -> expr PLUS expr .)
    MINUS           reduce using rule 92 (arith_op -> expr PLUS expr .)
    BOOL_AND        reduce using rule 92 (arith_op -> expr PLUS expr .)
    BOOL_OR         reduce using rule 92 (arith_op -> expr PLUS expr .)
    EQUALITY        reduce using rule 92 (arith_op -> expr PLUS expr .)
    DISQUALITY      reduce using rule 92 (arith_op -> expr PLUS expr .)
    LESSTHAN        reduce using rule 92 (arith_op -> expr PLUS expr .)
    GREATERTHAN     reduce using rule 92 (arith_op -> expr PLUS expr .)
    LEQ             reduce using rule 92 (arith_op -> expr PLUS expr .)
    GEQ             reduce using rule 92 (arith_op -> expr PLUS expr .)
    ;               reduce using rule 92 (arith_op -> expr PLUS expr .)
    ,               reduce using rule 92 (arith_op -> expr PLUS expr .)
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! MULTIPLY        [ reduce using rule 92 (arith_op -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 92 (arith_op -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 167

    (93) arith_op -> expr MINUS expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 93 (arith_op -> expr MINUS expr .)
    PLUS            reduce using rule 93 (arith_op -> expr MINUS expr .)
    MINUS           reduce using rule 93 (arith_op -> expr MINUS expr .)
    BOOL_AND        reduce using rule 93 (arith_op -> expr MINUS expr .)
    BOOL_OR         reduce using rule 93 (arith_op -> expr MINUS expr .)
    EQUALITY        reduce using rule 93 (arith_op -> expr MINUS expr .)
    DISQUALITY      reduce using rule 93 (arith_op -> expr MINUS expr .)
    LESSTHAN        reduce using rule 93 (arith_op -> expr MINUS expr .)
    GREATERTHAN     reduce using rule 93 (arith_op -> expr MINUS expr .)
    LEQ             reduce using rule 93 (arith_op -> expr MINUS expr .)
    GEQ             reduce using rule 93 (arith_op -> expr MINUS expr .)
    ;               reduce using rule 93 (arith_op -> expr MINUS expr .)
    ,               reduce using rule 93 (arith_op -> expr MINUS expr .)
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! MULTIPLY        [ reduce using rule 93 (arith_op -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 93 (arith_op -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 168

    (94) arith_op -> expr MULTIPLY expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    PLUS            reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    MINUS           reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    MULTIPLY        reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    DIVIDE          reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    BOOL_AND        reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    BOOL_OR         reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    EQUALITY        reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    DISQUALITY      reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    LESSTHAN        reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    GREATERTHAN     reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    LEQ             reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    GEQ             reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    ;               reduce using rule 94 (arith_op -> expr MULTIPLY expr .)
    ,               reduce using rule 94 (arith_op -> expr MULTIPLY expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 169

    (95) arith_op -> expr DIVIDE expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    PLUS            reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    MINUS           reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    MULTIPLY        reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    BOOL_AND        reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    BOOL_OR         reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    EQUALITY        reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    DISQUALITY      reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    LESSTHAN        reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    GREATERTHAN     reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    LEQ             reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    GEQ             reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    ;               reduce using rule 95 (arith_op -> expr DIVIDE expr .)
    ,               reduce using rule 95 (arith_op -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 139 ]
  ! MINUS           [ shift and go to state 140 ]
  ! MULTIPLY        [ shift and go to state 141 ]
  ! DIVIDE          [ shift and go to state 142 ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 170

    (96) bool_op -> expr BOOL_AND expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 96 (bool_op -> expr BOOL_AND expr .)
    BOOL_AND        reduce using rule 96 (bool_op -> expr BOOL_AND expr .)
    BOOL_OR         reduce using rule 96 (bool_op -> expr BOOL_AND expr .)
    ;               reduce using rule 96 (bool_op -> expr BOOL_AND expr .)
    ,               reduce using rule 96 (bool_op -> expr BOOL_AND expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150

  ! PLUS            [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! MINUS           [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! MULTIPLY        [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! DIVIDE          [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! EQUALITY        [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! DISQUALITY      [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! LESSTHAN        [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! GREATERTHAN     [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! LEQ             [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! GEQ             [ reduce using rule 96 (bool_op -> expr BOOL_AND expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]


state 171

    (97) bool_op -> expr BOOL_OR expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 97 (bool_op -> expr BOOL_OR expr .)
    BOOL_OR         reduce using rule 97 (bool_op -> expr BOOL_OR expr .)
    ;               reduce using rule 97 (bool_op -> expr BOOL_OR expr .)
    ,               reduce using rule 97 (bool_op -> expr BOOL_OR expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150

  ! PLUS            [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! MINUS           [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! MULTIPLY        [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! DIVIDE          [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! BOOL_AND        [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! EQUALITY        [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! DISQUALITY      [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! LESSTHAN        [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! GREATERTHAN     [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! LEQ             [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! GEQ             [ reduce using rule 97 (bool_op -> expr BOOL_OR expr .) ]
  ! BOOL_OR         [ shift and go to state 144 ]


state 172

    (98) bool_op -> expr EQUALITY expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    BOOL_AND        reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    BOOL_OR         reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    EQUALITY        reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    DISQUALITY      reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    ;               reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    ,               reduce using rule 98 (bool_op -> expr EQUALITY expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150

  ! PLUS            [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! MINUS           [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! MULTIPLY        [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! DIVIDE          [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! LESSTHAN        [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! GREATERTHAN     [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! LEQ             [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! GEQ             [ reduce using rule 98 (bool_op -> expr EQUALITY expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]


state 173

    (99) bool_op -> expr DISQUALITY expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    BOOL_AND        reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    BOOL_OR         reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    EQUALITY        reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    DISQUALITY      reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    ;               reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    ,               reduce using rule 99 (bool_op -> expr DISQUALITY expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150

  ! PLUS            [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! MINUS           [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! MULTIPLY        [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! DIVIDE          [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! LESSTHAN        [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! GREATERTHAN     [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! LEQ             [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! GEQ             [ reduce using rule 99 (bool_op -> expr DISQUALITY expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]


state 174

    (100) bool_op -> expr LESSTHAN expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    BOOL_AND        reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    BOOL_OR         reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    EQUALITY        reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    DISQUALITY      reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    LESSTHAN        reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    GREATERTHAN     reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    LEQ             reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    GEQ             reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    ;               reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    ,               reduce using rule 100 (bool_op -> expr LESSTHAN expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 100 (bool_op -> expr LESSTHAN expr .) ]
  ! MINUS           [ reduce using rule 100 (bool_op -> expr LESSTHAN expr .) ]
  ! MULTIPLY        [ reduce using rule 100 (bool_op -> expr LESSTHAN expr .) ]
  ! DIVIDE          [ reduce using rule 100 (bool_op -> expr LESSTHAN expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 175

    (101) bool_op -> expr GREATERTHAN expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    BOOL_AND        reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    BOOL_OR         reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    EQUALITY        reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    DISQUALITY      reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    LESSTHAN        reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    GREATERTHAN     reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    LEQ             reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    GEQ             reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    ;               reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    ,               reduce using rule 101 (bool_op -> expr GREATERTHAN expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 101 (bool_op -> expr GREATERTHAN expr .) ]
  ! MINUS           [ reduce using rule 101 (bool_op -> expr GREATERTHAN expr .) ]
  ! MULTIPLY        [ reduce using rule 101 (bool_op -> expr GREATERTHAN expr .) ]
  ! DIVIDE          [ reduce using rule 101 (bool_op -> expr GREATERTHAN expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 176

    (102) bool_op -> expr LEQ expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 102 (bool_op -> expr LEQ expr .)
    BOOL_AND        reduce using rule 102 (bool_op -> expr LEQ expr .)
    BOOL_OR         reduce using rule 102 (bool_op -> expr LEQ expr .)
    EQUALITY        reduce using rule 102 (bool_op -> expr LEQ expr .)
    DISQUALITY      reduce using rule 102 (bool_op -> expr LEQ expr .)
    LESSTHAN        reduce using rule 102 (bool_op -> expr LEQ expr .)
    GREATERTHAN     reduce using rule 102 (bool_op -> expr LEQ expr .)
    LEQ             reduce using rule 102 (bool_op -> expr LEQ expr .)
    GEQ             reduce using rule 102 (bool_op -> expr LEQ expr .)
    ;               reduce using rule 102 (bool_op -> expr LEQ expr .)
    ,               reduce using rule 102 (bool_op -> expr LEQ expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 102 (bool_op -> expr LEQ expr .) ]
  ! MINUS           [ reduce using rule 102 (bool_op -> expr LEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 102 (bool_op -> expr LEQ expr .) ]
  ! DIVIDE          [ reduce using rule 102 (bool_op -> expr LEQ expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 177

    (103) bool_op -> expr GEQ expr .
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      reduce using rule 103 (bool_op -> expr GEQ expr .)
    BOOL_AND        reduce using rule 103 (bool_op -> expr GEQ expr .)
    BOOL_OR         reduce using rule 103 (bool_op -> expr GEQ expr .)
    EQUALITY        reduce using rule 103 (bool_op -> expr GEQ expr .)
    DISQUALITY      reduce using rule 103 (bool_op -> expr GEQ expr .)
    LESSTHAN        reduce using rule 103 (bool_op -> expr GEQ expr .)
    GREATERTHAN     reduce using rule 103 (bool_op -> expr GEQ expr .)
    LEQ             reduce using rule 103 (bool_op -> expr GEQ expr .)
    GEQ             reduce using rule 103 (bool_op -> expr GEQ expr .)
    ;               reduce using rule 103 (bool_op -> expr GEQ expr .)
    ,               reduce using rule 103 (bool_op -> expr GEQ expr .)
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142

  ! PLUS            [ reduce using rule 103 (bool_op -> expr GEQ expr .) ]
  ! MINUS           [ reduce using rule 103 (bool_op -> expr GEQ expr .) ]
  ! MULTIPLY        [ reduce using rule 103 (bool_op -> expr GEQ expr .) ]
  ! DIVIDE          [ reduce using rule 103 (bool_op -> expr GEQ expr .) ]
  ! BOOL_AND        [ shift and go to state 143 ]
  ! BOOL_OR         [ shift and go to state 144 ]
  ! EQUALITY        [ shift and go to state 145 ]
  ! DISQUALITY      [ shift and go to state 146 ]
  ! LESSTHAN        [ shift and go to state 147 ]
  ! GREATERTHAN     [ shift and go to state 148 ]
  ! LEQ             [ shift and go to state 149 ]
  ! GEQ             [ shift and go to state 150 ]


state 178

    (43) open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN . open_stmt
    (53) close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN . close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    IF              shift and go to state 73
    WHILE           shift and go to state 75
    FOR             shift and go to state 76
    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    open_stmt                      shift and go to state 190
    close_stmt                     shift and go to state 191
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 179

    (44) open_stmt -> FOR LEFTPAREN temp_8 ; . temp_9 ; temp_8 RIGHTPAREN open_stmt
    (54) close_stmt -> FOR LEFTPAREN temp_8 ; . temp_9 ; temp_8 RIGHTPAREN close_stmt
    (57) temp_9 -> . expr
    (58) temp_9 -> . empty
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (107) empty -> .
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    ;               reduce using rule 107 (empty -> .)
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    temp_9                         shift and go to state 192
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 180

    (81) method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .

    ;               reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    .               reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    RIGHTPAREN      reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    PLUS            reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    MINUS           reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    MULTIPLY        reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    DIVIDE          reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    BOOL_AND        reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    BOOL_OR         reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    EQUALITY        reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    DISQUALITY      reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    LESSTHAN        reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    GREATERTHAN     reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    LEQ             reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    GEQ             reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)
    ,               reduce using rule 81 (method_invocation -> field_access LEFTPAREN test_1 RIGHTPAREN .)


state 181

    (74) test_1 -> expr test_2 .

    RIGHTPAREN      reduce using rule 74 (test_1 -> expr test_2 .)


state 182

    (76) test_2 -> , . expr test_2
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 193
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 183

    (77) test_2 -> empty .

    RIGHTPAREN      reduce using rule 77 (test_2 -> empty .)


state 184

    (71) primary -> NEW ID LEFTPAREN test_1 . RIGHTPAREN

    RIGHTPAREN      shift and go to state 194


state 185

    (52) close_stmt -> IF . LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (41) open_stmt -> IF . LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> IF . LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt

    LEFTPAREN       shift and go to state 195


state 186

    (41) open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .

    IF              reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    WHILE           reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    FOR             reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    RETURN          reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    BREAK           reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    CONTINUE        reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    ;               reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    {               reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    INCREMENT       reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    DECREMENT       reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    INT             reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    FLOAT           reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    BOOLEAN         reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    ID              reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    THIS            reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    SUPER           reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    LEFTPAREN       reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    NEW             reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    INT_CONST       reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    FLOAT_CONST     reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    STRING_CONST    reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    NULL            reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    TRUE            reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    FALSE           reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)
    }               reduce using rule 41 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN stmt .)


state 187

    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt . ELSE open_stmt
    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt . ELSE close_stmt
    (40) stmt -> close_stmt .

    ELSE            shift and go to state 196
    IF              reduce using rule 40 (stmt -> close_stmt .)
    WHILE           reduce using rule 40 (stmt -> close_stmt .)
    FOR             reduce using rule 40 (stmt -> close_stmt .)
    RETURN          reduce using rule 40 (stmt -> close_stmt .)
    BREAK           reduce using rule 40 (stmt -> close_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> close_stmt .)
    ;               reduce using rule 40 (stmt -> close_stmt .)
    {               reduce using rule 40 (stmt -> close_stmt .)
    INCREMENT       reduce using rule 40 (stmt -> close_stmt .)
    DECREMENT       reduce using rule 40 (stmt -> close_stmt .)
    INT             reduce using rule 40 (stmt -> close_stmt .)
    FLOAT           reduce using rule 40 (stmt -> close_stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> close_stmt .)
    ID              reduce using rule 40 (stmt -> close_stmt .)
    THIS            reduce using rule 40 (stmt -> close_stmt .)
    SUPER           reduce using rule 40 (stmt -> close_stmt .)
    LEFTPAREN       reduce using rule 40 (stmt -> close_stmt .)
    NEW             reduce using rule 40 (stmt -> close_stmt .)
    INT_CONST       reduce using rule 40 (stmt -> close_stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> close_stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> close_stmt .)
    NULL            reduce using rule 40 (stmt -> close_stmt .)
    TRUE            reduce using rule 40 (stmt -> close_stmt .)
    FALSE           reduce using rule 40 (stmt -> close_stmt .)
    }               reduce using rule 40 (stmt -> close_stmt .)


state 188

    (53) close_stmt -> WHILE . LEFTPAREN expr RIGHTPAREN close_stmt
    (43) open_stmt -> WHILE . LEFTPAREN expr RIGHTPAREN open_stmt

    LEFTPAREN       shift and go to state 197


state 189

    (54) close_stmt -> FOR . LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (44) open_stmt -> FOR . LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt

    LEFTPAREN       shift and go to state 198


state 190

    (43) open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .

    IF              reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    WHILE           reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    FOR             reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    RETURN          reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    BREAK           reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    CONTINUE        reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    ;               reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    {               reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    INCREMENT       reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    DECREMENT       reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    INT             reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    FLOAT           reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    BOOLEAN         reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    ID              reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    THIS            reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    SUPER           reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    LEFTPAREN       reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    NEW             reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    INT_CONST       reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    FLOAT_CONST     reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    STRING_CONST    reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    NULL            reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    TRUE            reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    FALSE           reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)
    }               reduce using rule 43 (open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN open_stmt .)


state 191

    (53) close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .

    IF              reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    WHILE           reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    FOR             reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    RETURN          reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    BREAK           reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    CONTINUE        reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    ;               reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    {               reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    INCREMENT       reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    DECREMENT       reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    INT             reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    FLOAT           reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    BOOLEAN         reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    ID              reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    THIS            reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    SUPER           reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    LEFTPAREN       reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    NEW             reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    INT_CONST       reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    FLOAT_CONST     reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    STRING_CONST    reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    NULL            reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    TRUE            reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    FALSE           reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    }               reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)
    ELSE            reduce using rule 53 (close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN close_stmt .)


state 192

    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 . ; temp_8 RIGHTPAREN open_stmt
    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 . ; temp_8 RIGHTPAREN close_stmt

    ;               shift and go to state 199


state 193

    (76) test_2 -> , expr . test_2
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr
    (76) test_2 -> . , expr test_2
    (77) test_2 -> . empty
    (107) empty -> .

    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150
    ,               shift and go to state 182
    RIGHTPAREN      reduce using rule 107 (empty -> .)

    test_2                         shift and go to state 200
    empty                          shift and go to state 183

state 194

    (71) primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .

    .               reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    RIGHTPAREN      reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    PLUS            reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    MINUS           reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    MULTIPLY        reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    DIVIDE          reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    BOOL_AND        reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    BOOL_OR         reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    EQUALITY        reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    DISQUALITY      reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    LESSTHAN        reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    GREATERTHAN     reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    LEQ             reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    GEQ             reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    ;               reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)
    ,               reduce using rule 71 (primary -> NEW ID LEFTPAREN test_1 RIGHTPAREN .)


state 195

    (52) close_stmt -> IF LEFTPAREN . expr RIGHTPAREN close_stmt ELSE close_stmt
    (41) open_stmt -> IF LEFTPAREN . expr RIGHTPAREN stmt
    (42) open_stmt -> IF LEFTPAREN . expr RIGHTPAREN close_stmt ELSE open_stmt
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 201
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 196

    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE . open_stmt
    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE . close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    IF              shift and go to state 73
    WHILE           shift and go to state 75
    FOR             shift and go to state 76
    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    close_stmt                     shift and go to state 202
    open_stmt                      shift and go to state 203
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 197

    (53) close_stmt -> WHILE LEFTPAREN . expr RIGHTPAREN close_stmt
    (43) open_stmt -> WHILE LEFTPAREN . expr RIGHTPAREN open_stmt
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    expr                           shift and go to state 204
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 198

    (54) close_stmt -> FOR LEFTPAREN . temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (44) open_stmt -> FOR LEFTPAREN . temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (55) temp_8 -> . stmt_expr
    (56) temp_8 -> . empty
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (107) empty -> .
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    ;               reduce using rule 107 (empty -> .)
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    ID              shift and go to state 114
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    temp_8                         shift and go to state 205
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 199

    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; . temp_8 RIGHTPAREN open_stmt
    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; . temp_8 RIGHTPAREN close_stmt
    (55) temp_8 -> . stmt_expr
    (56) temp_8 -> . empty
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (107) empty -> .
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    ID              shift and go to state 114
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    temp_8                         shift and go to state 206
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 200

    (76) test_2 -> , expr test_2 .

    RIGHTPAREN      reduce using rule 76 (test_2 -> , expr test_2 .)


state 201

    (52) close_stmt -> IF LEFTPAREN expr . RIGHTPAREN close_stmt ELSE close_stmt
    (41) open_stmt -> IF LEFTPAREN expr . RIGHTPAREN stmt
    (42) open_stmt -> IF LEFTPAREN expr . RIGHTPAREN close_stmt ELSE open_stmt
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      shift and go to state 207
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150


state 202

    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .

    IF              reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    WHILE           reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    FOR             reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    RETURN          reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    BREAK           reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    CONTINUE        reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    ;               reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    {               reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    INCREMENT       reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    DECREMENT       reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    INT             reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    FLOAT           reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    BOOLEAN         reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    ID              reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    THIS            reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    SUPER           reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    LEFTPAREN       reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    NEW             reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    INT_CONST       reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    FLOAT_CONST     reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    STRING_CONST    reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    NULL            reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    TRUE            reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    FALSE           reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    }               reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)
    ELSE            reduce using rule 52 (close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt .)


state 203

    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .

    IF              reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    WHILE           reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    FOR             reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    RETURN          reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    BREAK           reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    CONTINUE        reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    ;               reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    {               reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    INCREMENT       reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    DECREMENT       reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    INT             reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    FLOAT           reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    BOOLEAN         reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    ID              reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    THIS            reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    SUPER           reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    LEFTPAREN       reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    NEW             reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    INT_CONST       reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    FLOAT_CONST     reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    STRING_CONST    reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    NULL            reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    TRUE            reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    FALSE           reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)
    }               reduce using rule 42 (open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt .)


state 204

    (53) close_stmt -> WHILE LEFTPAREN expr . RIGHTPAREN close_stmt
    (43) open_stmt -> WHILE LEFTPAREN expr . RIGHTPAREN open_stmt
    (92) arith_op -> expr . PLUS expr
    (93) arith_op -> expr . MINUS expr
    (94) arith_op -> expr . MULTIPLY expr
    (95) arith_op -> expr . DIVIDE expr
    (96) bool_op -> expr . BOOL_AND expr
    (97) bool_op -> expr . BOOL_OR expr
    (98) bool_op -> expr . EQUALITY expr
    (99) bool_op -> expr . DISQUALITY expr
    (100) bool_op -> expr . LESSTHAN expr
    (101) bool_op -> expr . GREATERTHAN expr
    (102) bool_op -> expr . LEQ expr
    (103) bool_op -> expr . GEQ expr

    RIGHTPAREN      shift and go to state 208
    PLUS            shift and go to state 139
    MINUS           shift and go to state 140
    MULTIPLY        shift and go to state 141
    DIVIDE          shift and go to state 142
    BOOL_AND        shift and go to state 143
    BOOL_OR         shift and go to state 144
    EQUALITY        shift and go to state 145
    DISQUALITY      shift and go to state 146
    LESSTHAN        shift and go to state 147
    GREATERTHAN     shift and go to state 148
    LEQ             shift and go to state 149
    GEQ             shift and go to state 150


state 205

    (54) close_stmt -> FOR LEFTPAREN temp_8 . ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (44) open_stmt -> FOR LEFTPAREN temp_8 . ; temp_9 ; temp_8 RIGHTPAREN open_stmt

    ;               shift and go to state 209


state 206

    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 . RIGHTPAREN open_stmt
    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 . RIGHTPAREN close_stmt

    RIGHTPAREN      shift and go to state 210


state 207

    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN . close_stmt ELSE close_stmt
    (41) open_stmt -> IF LEFTPAREN expr RIGHTPAREN . stmt
    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN . close_stmt ELSE open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (39) stmt -> . open_stmt
    (40) stmt -> . close_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    IF              shift and go to state 185
    WHILE           shift and go to state 188
    FOR             shift and go to state 189
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    close_stmt                     shift and go to state 211
    stmt                           shift and go to state 186
    open_stmt                      shift and go to state 71
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 208

    (53) close_stmt -> WHILE LEFTPAREN expr RIGHTPAREN . close_stmt
    (43) open_stmt -> WHILE LEFTPAREN expr RIGHTPAREN . open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    IF              shift and go to state 185
    WHILE           shift and go to state 188
    FOR             shift and go to state 189
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    close_stmt                     shift and go to state 191
    open_stmt                      shift and go to state 190
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 209

    (54) close_stmt -> FOR LEFTPAREN temp_8 ; . temp_9 ; temp_8 RIGHTPAREN close_stmt
    (44) open_stmt -> FOR LEFTPAREN temp_8 ; . temp_9 ; temp_8 RIGHTPAREN open_stmt
    (57) temp_9 -> . expr
    (58) temp_9 -> . empty
    (82) expr -> . primary
    (83) expr -> . assign
    (84) expr -> . arith_op
    (85) expr -> . bool_op
    (86) expr -> . unary_op
    (107) empty -> .
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (92) arith_op -> . expr PLUS expr
    (93) arith_op -> . expr MINUS expr
    (94) arith_op -> . expr MULTIPLY expr
    (95) arith_op -> . expr DIVIDE expr
    (96) bool_op -> . expr BOOL_AND expr
    (97) bool_op -> . expr BOOL_OR expr
    (98) bool_op -> . expr EQUALITY expr
    (99) bool_op -> . expr DISQUALITY expr
    (100) bool_op -> . expr LESSTHAN expr
    (101) bool_op -> . expr GREATERTHAN expr
    (102) bool_op -> . expr LEQ expr
    (103) bool_op -> . expr GEQ expr
    (104) unary_op -> . PLUS expr
    (105) unary_op -> . MINUS expr
    (106) unary_op -> . NOT expr
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE
    (78) lhs -> . field_access
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (79) field_access -> . primary . ID
    (80) field_access -> . ID

    ;               reduce using rule 107 (empty -> .)
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    NOT             shift and go to state 119
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102
    ID              shift and go to state 114

    temp_9                         shift and go to state 212
    expr                           shift and go to state 124
    empty                          shift and go to state 125
    primary                        shift and go to state 109
    assign                         shift and go to state 110
    arith_op                       shift and go to state 111
    bool_op                        shift and go to state 112
    unary_op                       shift and go to state 113
    literal                        shift and go to state 93
    lhs                            shift and go to state 115
    method_invocation              shift and go to state 116
    field_access                   shift and go to state 120

state 210

    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN . open_stmt
    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN . close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    IF              shift and go to state 73
    WHILE           shift and go to state 75
    FOR             shift and go to state 76
    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    open_stmt                      shift and go to state 213
    close_stmt                     shift and go to state 214
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 211

    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt . ELSE close_stmt
    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt . ELSE open_stmt
    (40) stmt -> close_stmt .

    ELSE            shift and go to state 215
    IF              reduce using rule 40 (stmt -> close_stmt .)
    WHILE           reduce using rule 40 (stmt -> close_stmt .)
    FOR             reduce using rule 40 (stmt -> close_stmt .)
    RETURN          reduce using rule 40 (stmt -> close_stmt .)
    BREAK           reduce using rule 40 (stmt -> close_stmt .)
    CONTINUE        reduce using rule 40 (stmt -> close_stmt .)
    ;               reduce using rule 40 (stmt -> close_stmt .)
    {               reduce using rule 40 (stmt -> close_stmt .)
    INCREMENT       reduce using rule 40 (stmt -> close_stmt .)
    DECREMENT       reduce using rule 40 (stmt -> close_stmt .)
    INT             reduce using rule 40 (stmt -> close_stmt .)
    FLOAT           reduce using rule 40 (stmt -> close_stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> close_stmt .)
    ID              reduce using rule 40 (stmt -> close_stmt .)
    THIS            reduce using rule 40 (stmt -> close_stmt .)
    SUPER           reduce using rule 40 (stmt -> close_stmt .)
    LEFTPAREN       reduce using rule 40 (stmt -> close_stmt .)
    NEW             reduce using rule 40 (stmt -> close_stmt .)
    INT_CONST       reduce using rule 40 (stmt -> close_stmt .)
    FLOAT_CONST     reduce using rule 40 (stmt -> close_stmt .)
    STRING_CONST    reduce using rule 40 (stmt -> close_stmt .)
    NULL            reduce using rule 40 (stmt -> close_stmt .)
    TRUE            reduce using rule 40 (stmt -> close_stmt .)
    FALSE           reduce using rule 40 (stmt -> close_stmt .)
    }               reduce using rule 40 (stmt -> close_stmt .)


state 212

    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 . ; temp_8 RIGHTPAREN close_stmt
    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 . ; temp_8 RIGHTPAREN open_stmt

    ;               shift and go to state 216


state 213

    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .

    IF              reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    WHILE           reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    FOR             reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    RETURN          reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    BREAK           reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    CONTINUE        reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    ;               reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    {               reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    INCREMENT       reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    DECREMENT       reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    INT             reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    FLOAT           reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    BOOLEAN         reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    ID              reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    THIS            reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    SUPER           reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    LEFTPAREN       reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    NEW             reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    INT_CONST       reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    FLOAT_CONST     reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    STRING_CONST    reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    NULL            reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    TRUE            reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    FALSE           reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)
    }               reduce using rule 44 (open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt .)


state 214

    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .

    IF              reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    WHILE           reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    FOR             reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    RETURN          reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    BREAK           reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    CONTINUE        reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    ;               reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    {               reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    INCREMENT       reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    DECREMENT       reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    INT             reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    FLOAT           reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    BOOLEAN         reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    ID              reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    THIS            reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    SUPER           reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    LEFTPAREN       reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    NEW             reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    INT_CONST       reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    FLOAT_CONST     reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    STRING_CONST    reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    NULL            reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    TRUE            reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    FALSE           reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    }               reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)
    ELSE            reduce using rule 54 (close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt .)


state 215

    (52) close_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE . close_stmt
    (42) open_stmt -> IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE . open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    IF              shift and go to state 185
    WHILE           shift and go to state 188
    FOR             shift and go to state 189
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    close_stmt                     shift and go to state 202
    open_stmt                      shift and go to state 203
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 216

    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; . temp_8 RIGHTPAREN close_stmt
    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; . temp_8 RIGHTPAREN open_stmt
    (55) temp_8 -> . stmt_expr
    (56) temp_8 -> . empty
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (107) empty -> .
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RIGHTPAREN      reduce using rule 107 (empty -> .)
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    ID              shift and go to state 114
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    temp_8                         shift and go to state 217
    stmt_expr                      shift and go to state 156
    empty                          shift and go to state 157
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93

state 217

    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 . RIGHTPAREN close_stmt
    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 . RIGHTPAREN open_stmt

    RIGHTPAREN      shift and go to state 218


state 218

    (54) close_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN . close_stmt
    (44) open_stmt -> FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN . open_stmt
    (45) close_stmt -> . RETURN temp_9 ;
    (46) close_stmt -> . stmt_expr ;
    (47) close_stmt -> . BREAK ;
    (48) close_stmt -> . CONTINUE ;
    (49) close_stmt -> . var_decl
    (50) close_stmt -> . ;
    (51) close_stmt -> . block
    (52) close_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE close_stmt
    (53) close_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN close_stmt
    (54) close_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN close_stmt
    (41) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN stmt
    (42) open_stmt -> . IF LEFTPAREN expr RIGHTPAREN close_stmt ELSE open_stmt
    (43) open_stmt -> . WHILE LEFTPAREN expr RIGHTPAREN open_stmt
    (44) open_stmt -> . FOR LEFTPAREN temp_8 ; temp_9 ; temp_8 RIGHTPAREN open_stmt
    (59) stmt_expr -> . assign
    (60) stmt_expr -> . method_invocation
    (19) var_decl -> . type variables ;
    (36) block -> . { temp_7 }
    (87) assign -> . lhs = expr
    (88) assign -> . lhs INCREMENT
    (89) assign -> . INCREMENT lhs
    (90) assign -> . lhs DECREMENT
    (91) assign -> . DECREMENT lhs
    (81) method_invocation -> . field_access LEFTPAREN test_1 RIGHTPAREN
    (20) type -> . INT
    (21) type -> . FLOAT
    (22) type -> . BOOLEAN
    (23) type -> . ID
    (78) lhs -> . field_access
    (79) field_access -> . primary . ID
    (80) field_access -> . ID
    (67) primary -> . literal
    (68) primary -> . THIS
    (69) primary -> . SUPER
    (70) primary -> . LEFTPAREN expr RIGHTPAREN
    (71) primary -> . NEW ID LEFTPAREN test_1 RIGHTPAREN
    (72) primary -> . lhs
    (73) primary -> . method_invocation
    (61) literal -> . INT_CONST
    (62) literal -> . FLOAT_CONST
    (63) literal -> . STRING_CONST
    (64) literal -> . NULL
    (65) literal -> . TRUE
    (66) literal -> . FALSE

    RETURN          shift and go to state 78
    BREAK           shift and go to state 80
    CONTINUE        shift and go to state 81
    ;               shift and go to state 77
    IF              shift and go to state 185
    WHILE           shift and go to state 188
    FOR             shift and go to state 189
    {               shift and go to state 64
    INCREMENT       shift and go to state 88
    DECREMENT       shift and go to state 89
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    BOOLEAN         shift and go to state 31
    ID              shift and go to state 91
    THIS            shift and go to state 94
    SUPER           shift and go to state 95
    LEFTPAREN       shift and go to state 74
    NEW             shift and go to state 96
    INT_CONST       shift and go to state 97
    FLOAT_CONST     shift and go to state 98
    STRING_CONST    shift and go to state 99
    NULL            shift and go to state 100
    TRUE            shift and go to state 101
    FALSE           shift and go to state 102

    close_stmt                     shift and go to state 214
    open_stmt                      shift and go to state 213
    stmt_expr                      shift and go to state 79
    var_decl                       shift and go to state 82
    block                          shift and go to state 83
    assign                         shift and go to state 84
    method_invocation              shift and go to state 85
    type                           shift and go to state 86
    lhs                            shift and go to state 87
    field_access                   shift and go to state 90
    primary                        shift and go to state 92
    literal                        shift and go to state 93
